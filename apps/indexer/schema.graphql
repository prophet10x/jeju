# Subsquid Schema for Jeju Network
# Core blockchain indexing entities

# ============ Core Blockchain Entities ============

type Block @entity {
  id: ID!
  number: Int! @index
  hash: String!
  parentHash: String!
  timestamp: DateTime! @index
  transactionCount: Int!
  gasUsed: BigInt!
  gasLimit: BigInt!
  baseFeePerGas: BigInt
  size: Int!
  miner: Account
  transactions: [Transaction!]! @derivedFrom(field: "block")
  logs: [Log!]! @derivedFrom(field: "block")
}

type Transaction @entity {
  id: ID!
  hash: String! @unique @index
  from: Account!
  to: Account
  block: Block!
  blockNumber: Int! @index
  transactionIndex: Int!
  value: BigInt!
  gasPrice: BigInt
  gasLimit: BigInt!
  gasUsed: BigInt
  input: String
  nonce: Int!
  status: TransactionStatus!
  type: Int
  maxFeePerGas: BigInt
  maxPriorityFeePerGas: BigInt
  contractAddress: Account
  logs: [Log!]! @derivedFrom(field: "transaction")
  traces: [Trace!]! @derivedFrom(field: "transaction")
}

enum TransactionStatus {
  SUCCESS
  FAILURE
  PENDING
}

type Account @entity {
  id: ID!
  address: String! @unique @index
  isContract: Boolean!
  firstSeenBlock: Int! @index
  lastSeenBlock: Int! @index
  transactionCount: Int!
  totalValueSent: BigInt!
  totalValueReceived: BigInt!
  labels: [String!]!
  contract: Contract
  firstSeenAt: DateTime! @index
  lastSeenAt: DateTime! @index
  sentTransactions: [Transaction!]! @derivedFrom(field: "from")
  receivedTransactions: [Transaction!]! @derivedFrom(field: "to")
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "account")
  createdContracts: [Contract!]! @derivedFrom(field: "creator")
  tokenTransfersFrom: [TokenTransfer!]! @derivedFrom(field: "from")
  tokenTransfersTo: [TokenTransfer!]! @derivedFrom(field: "to")
}

type Contract @entity {
  id: ID!
  address: String! @unique @index
  bytecode: String
  contractType: ContractType
  isERC20: Boolean!
  isERC721: Boolean!
  isERC1155: Boolean!
  isProxy: Boolean!
  implementationAddress: String
  verified: Boolean!
  firstSeenAt: DateTime! @index
  lastSeenAt: DateTime! @index
  creator: Account
  creationTransaction: Transaction
  creationBlock: Block
  tokenTransfers: [TokenTransfer!]! @derivedFrom(field: "token")
}

enum ContractType {
  UNKNOWN
  ERC20
  ERC721
  ERC1155
  PROXY
  MULTISIG
  DEX
  LENDING
  NFT_MARKETPLACE
  GAME
  PREDICTION_MARKET
  GOVERNANCE
}

type Log @entity {
  id: ID!
  address: Account!
  data: String!
  topic0: String @index
  topic1: String @index
  topic2: String @index
  topic3: String @index
  block: Block!
  transaction: Transaction!
  logIndex: Int!
  transactionIndex: Int!
  removed: Boolean!
  decodedEvent: DecodedEvent
}

type DecodedEvent @entity {
  id: ID!
  eventSignature: String!
  eventName: String! @index
  args: JSON!
  address: Account!
  block: Block!
  transaction: Transaction!
  log: Log! @unique
  timestamp: DateTime! @index
}

type Trace @entity {
  id: ID!
  type: TraceType!
  from: Account!
  to: Account
  value: BigInt
  gas: BigInt
  gasUsed: BigInt
  input: String
  output: String
  error: String
  transaction: Transaction!
  traceAddress: [Int!]!
}

enum TraceType {
  CALL
  DELEGATECALL
  STATICCALL
  CREATE
  CREATE2
  SELFDESTRUCT
}

enum EventCategory {
  TOKEN
  NFT
  DEFI
  GAME
  GOVERNANCE
  UNKNOWN
}

type TokenTransfer @entity {
  id: ID!
  logIndex: Int!
  tokenStandard: TokenStandard! @index
  from: Account!
  to: Account!
  operator: Account
  token: Contract
  value: BigInt
  tokenId: String
  block: Block!
  transaction: Transaction!
  timestamp: DateTime! @index
}

enum TokenStandard {
  ERC20
  ERC721
  ERC1155
}

type TokenBalance @entity {
  id: ID!
  account: Account!
  token: Contract!
  balance: BigInt!
  transferCount: Int!
  lastUpdated: DateTime! @index
}

# ============ IPFS & Cross-Service Integration ============

type IPFSFile @entity {
  id: ID! # CID (bytes32 as string)
  cid: String! @index
  owner: Bytes! @index
  sizeBytes: BigInt!
  paidAmount: BigInt!
  paymentToken: Bytes!
  createdAt: DateTime! @index
  expiresAt: DateTime! @index
  isPinned: Boolean!
  
  # Categorization
  category: FileCategory! @index
  relatedContract: Bytes @index
  relatedEntityId: String @index
  
  # Metadata
  filename: String
  mimeType: String
  
  # Relations
  moderationReport: ModerationReport
  teeAttestation: TEEAttestation
  nftMetadata: NFTMetadata
  agentProfile: AgentProfile
  contestResult: ContestResult
}

enum FileCategory {
  MODERATION_EVIDENCE
  TEE_ATTESTATION
  GAME_ASSET
  NFT_METADATA
  AGENT_PROFILE
  CONTEST_RESULT
  ORACLE_DATA
  USER_CONTENT
  CONTAINER_IMAGE
  MODEL_WEIGHTS
  COMPUTE_OUTPUT
}

type ModerationReport @entity {
  id: ID!
  reportId: BigInt!
  targetAgentId: BigInt!
  reporter: Bytes!
  reportType: ReportType!
  severity: ReportSeverity!
  evidenceIPFS: IPFSFile # Link to IPFS file
  details: String!
  status: ReportStatus!
  createdAt: DateTime!
}

enum ReportType {
  NETWORK_BAN
  APP_BAN
  LABEL_HACKER
  LABEL_SCAMMER
}

enum ReportSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ReportStatus {
  PENDING
  RESOLVED_YES
  RESOLVED_NO
  EXECUTED
}

type TEEAttestation @entity {
  id: ID!
  sessionId: Bytes!
  attestationIPFS: IPFSFile # TEE quote stored on IPFS
  contentHash: Bytes! # For verification
  gameType: GameType!
  timestamp: DateTime!
  verified: Boolean!
}

# Game types - GENERIC should be used for new games
# Specific game types are legacy and will be deprecated in favor of dynamic registration
enum GameType {
  GENERIC
  # Legacy game types (retained for backwards compatibility)
  CALIGULAND
  EHORSE
  HYPERSCAPE
}

type AgentProfile @entity {
  id: ID!
  agentId: BigInt!
  owner: Bytes!
  profileIPFS: IPFSFile # Profile JSON on IPFS
  stakeTier: Int!
  registered: DateTime!
  isBanned: Boolean!
}

type NFTMetadata @entity {
  id: ID!
  tokenId: BigInt!
  contract: Bytes!
  metadataIPFS: IPFSFile # Metadata JSON on IPFS
  owner: Bytes!
  mintedAt: DateTime!
}

type ContestResult @entity {
  id: ID!
  contestId: Bytes!
  resultsIPFS: IPFSFile # Full rankings on IPFS
  winner: Int!
  finalized: DateTime!
}

type StorageStats @entity {
  id: ID! # Date string
  date: DateTime!
  totalFiles: BigInt!
  totalSizeBytes: BigInt!
  totalRevenue: BigInt!
  activeUsers: BigInt!
  
  # By category
  evidenceFiles: BigInt!
  attestationFiles: BigInt!
  assetFiles: BigInt!
  metadataFiles: BigInt!
}

# ============ Game Feed & Player Events ============

type GameFeedPost @entity {
  id: ID!
  sessionId: String! @index
  postId: String! @index
  author: String! @index
  content: String!
  gameDay: Int!
  timestamp: DateTime! @index
  isSystemMessage: Boolean!
  blockNumber: BigInt!
  transactionHash: String!
}

type GameMarketUpdate @entity {
  id: ID!
  sessionId: String! @index
  yesOdds: Int!
  noOdds: Int!
  totalVolume: BigInt!
  gameDay: Int!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type GamePhaseChange @entity {
  id: ID!
  sessionId: String! @index
  phase: String!
  day: Int!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerSkillEvent @entity {
  id: ID!
  player: String! @index
  skillName: String!
  newLevel: Int!
  totalXp: BigInt!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerDeathEvent @entity {
  id: ID!
  player: String! @index
  killer: String @index
  location: String!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerKillEvent @entity {
  id: ID!
  killer: String! @index
  victim: String! @index
  method: String!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerAchievement @entity {
  id: ID!
  player: String! @index
  achievementId: String!
  achievementType: String!
  value: BigInt!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerStats @entity {
  id: ID! # player address
  player: String! @unique @index
  totalSkillEvents: Int!
  totalDeaths: Int!
  totalKills: Int!
  totalAchievements: Int!
  highestSkillLevel: Int!
  highestSkillName: String
  lastActive: DateTime! @index
}

# ============ Node Staking & Governance ============

type NodeStake @entity {
  id: ID! # nodeId
  nodeId: String! @unique @index
  operator: String! @index
  stakedToken: String!
  stakedAmount: BigInt!
  stakedValueUSD: BigInt!
  rewardToken: String!
  totalRewardsClaimed: BigInt!
  lastClaimTime: BigInt!
  rpcUrl: String!
  geographicRegion: Int!
  registrationTime: BigInt!
  isActive: Boolean!
  isSlashed: Boolean!
  currentUptimeScore: BigInt
  currentRequestsServed: BigInt
  currentAvgResponseTime: BigInt
  performanceUpdates: [PerformanceUpdate!]! @derivedFrom(field: "node")
  rewardClaims: [RewardClaim!]! @derivedFrom(field: "node")
}

type PerformanceUpdate @entity {
  id: ID!
  node: NodeStake!
  uptimeScore: BigInt!
  requestsServed: BigInt!
  avgResponseTime: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}

type RewardClaim @entity {
  id: ID!
  node: NodeStake!
  operator: String!
  rewardToken: String!
  rewardAmount: BigInt!
  paymasterFeesETH: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}

type OperatorStats @entity {
  id: ID! # operator address
  operator: String! @unique @index
  totalNodes: Int!
  totalStaked: BigInt!
  totalRewardsClaimed: BigInt!
  averageUptime: BigInt!
  lastActive: DateTime! @index
}

type TokenDistribution @entity {
  id: ID!
  token: String! @index
  totalStaked: BigInt!
  totalNodes: Int!
  averageStake: BigInt!
  lastUpdated: DateTime! @index
}

type NetworkSnapshot @entity {
  id: ID! # timestamp
  timestamp: DateTime! @index
  totalNodes: Int!
  activeNodes: Int!
  totalStaked: BigInt!
  totalStakedUSD: BigInt!
  averageUptime: BigInt!
}

type GovernanceProposal @entity {
  id: ID! # proposalId
  proposalId: Bytes! @unique @index
  parameter: String!
  currentValue: BigInt!
  proposedValue: BigInt!
  changeMarketId: Bytes!
  statusQuoMarketId: Bytes!
  createdAt: BigInt!
  votingEnds: BigInt!
  executeAfter: BigInt!
  executed: Boolean!
  vetoed: Boolean!
  proposer: String!
  events: [GovernanceEvent!]! @derivedFrom(field: "proposal")
}

type GovernanceEvent @entity {
  id: ID!
  proposal: GovernanceProposal!
  eventType: String!
  actor: String
  reason: String
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}

# ============ AI Council Governance ============

type CouncilProposal @entity {
  id: ID! # proposalId bytes32
  proposalId: Bytes! @unique @index
  proposer: Account!
  proposerAgentId: BigInt
  proposalType: Int! # enum: PARAMETER_CHANGE, TREASURY_ALLOCATION, etc.
  status: String! @index # SUBMITTED, COUNCIL_REVIEW, APPROVED, etc.
  qualityScore: Int!
  contentHash: Bytes!
  targetContract: String
  callData: Bytes
  value: BigInt!
  totalStaked: BigInt!
  totalReputation: BigInt!
  backerCount: Int!
  hasResearch: Boolean!
  researchHash: Bytes
  ceoApproved: Boolean!
  ceoDecisionHash: Bytes
  createdAt: DateTime! @index
  councilVoteEnd: DateTime
  gracePeriodEnd: DateTime
  executedAt: DateTime
  councilVotes: [CouncilVote!]! @derivedFrom(field: "proposal")
  backers: [ProposalBacker!]! @derivedFrom(field: "proposal")
  vetoVotes: [VetoVote!]! @derivedFrom(field: "proposal")
}

type CouncilVote @entity {
  id: ID!
  proposal: CouncilProposal!
  councilAgent: Account!
  role: String! # TREASURY, CODE, COMMUNITY, SECURITY
  vote: String! # APPROVE, REJECT, ABSTAIN, REQUEST_CHANGES
  reasoningHash: Bytes!
  weight: BigInt!
  votedAt: DateTime! @index
  blockNumber: Int!
  transactionHash: String!
}

type ProposalBacker @entity {
  id: ID!
  proposal: CouncilProposal!
  backer: Account!
  agentId: BigInt
  stakedAmount: BigInt!
  reputationWeight: BigInt!
  backedAt: DateTime! @index
}

type VetoVote @entity {
  id: ID!
  proposal: CouncilProposal!
  voter: Account!
  agentId: BigInt
  category: String! # ALREADY_DONE, DUPLICATE, IMPOSSIBLE, HARMFUL, etc.
  reasonHash: Bytes!
  stakedAmount: BigInt!
  reputationWeight: BigInt!
  votedAt: DateTime! @index
}

type CEODecision @entity {
  id: ID! # decisionId
  proposal: CouncilProposal!
  modelId: String!
  approved: Boolean!
  decisionHash: Bytes!
  encryptedHash: Bytes!
  contextHash: Bytes!
  confidenceScore: Int!
  alignmentScore: Int!
  disputed: Boolean!
  overridden: Boolean!
  decidedAt: DateTime! @index
  blockNumber: Int!
  transactionHash: String!
}

# ============ Delegation System ============

type Delegate @entity {
  id: ID! # delegate address
  delegate: Account!
  agentId: BigInt
  name: String!
  profileHash: String
  expertise: [String!]!
  totalDelegated: BigInt!
  delegatorCount: Int!
  isActive: Boolean!
  isSecurityCouncil: Boolean! @index
  proposalsVoted: Int!
  proposalsCreated: Int!
  registeredAt: DateTime! @index
  delegations: [Delegation!]! @derivedFrom(field: "delegate")
}

type Delegation @entity {
  id: ID! # delegator address
  delegator: Account!
  delegate: Delegate!
  amount: BigInt!
  lockedUntil: DateTime
  delegatedAt: DateTime! @index
  revokedAt: DateTime
  active: Boolean! @index
}

type SecurityCouncilMember @entity {
  id: ID! # member address + election timestamp
  member: Account!
  agentId: BigInt
  combinedScore: BigInt!
  electedAt: DateTime! @index
  removedAt: DateTime
  active: Boolean! @index
}

type SecurityCouncilUpdate @entity {
  id: ID!
  members: [String!]!
  memberCount: Int!
  updatedAt: DateTime! @index
  blockNumber: Int!
  transactionHash: String!
}

# ============ Circuit Breaker ============

type ProtectedContract @entity {
  id: ID! # contract address
  target: Account!
  name: String!
  priority: Int!
  isPaused: Boolean! @index
  pausedAt: DateTime
  pausedBy: Account
  pauseReason: String
  registeredAt: DateTime! @index
}

type PauseEvent @entity {
  id: ID! # eventId
  target: ProtectedContract!
  pauser: Account
  reason: String!
  isGlobal: Boolean!
  wasEmergency: Boolean!
  pausedAt: DateTime! @index
  unpausedAt: DateTime
  blockNumber: Int!
  transactionHash: String!
}

type AnomalyDetection @entity {
  id: ID!
  target: ProtectedContract!
  anomalyType: String! # HIGH_TX_COUNT, HIGH_TX_VALUE, HIGH_HOURLY_VALUE
  value: BigInt!
  threshold: BigInt!
  autoPaused: Boolean!
  detectedAt: DateTime! @index
  blockNumber: Int!
}

# ============ Safe Multi-Sig ============

type SafeExecution @entity {
  id: ID! # executionId
  proposalId: Bytes!
  target: String!
  value: BigInt!
  data: Bytes
  humanApprovals: Int!
  aiApproved: Boolean!
  executed: Boolean!
  cancelled: Boolean!
  createdAt: DateTime! @index
  executedAt: DateTime
  approvals: [SafeApproval!]! @derivedFrom(field: "execution")
}

type SafeApproval @entity {
  id: ID!
  execution: SafeExecution!
  approver: Account!
  isAI: Boolean!
  attestationHash: Bytes
  approvedAt: DateTime! @index
  blockNumber: Int!
  transactionHash: String!
}

# ============ ERC-8004 Registry ============

type RegisteredAgent @entity {
  id: ID!
  agentId: BigInt! @unique @index
  owner: Account!
  tokenURI: String
  name: String!
  description: String
  tags: [String!]!
  stakeTier: Int!
  stakeToken: String!
  stakeAmount: BigInt!
  stakeWithdrawn: Boolean!
  isSlashed: Boolean!
  isBanned: Boolean!
  registeredAt: DateTime! @index
  depositedAt: BigInt!
  withdrawnAt: BigInt
  lastActivityAt: DateTime
  active: Boolean!
  
  # Marketplace Discovery Fields
  a2aEndpoint: String
  mcpEndpoint: String
  serviceType: String @index # "agent", "mcp", "app"
  category: String @index
  x402Support: Boolean!
  
  # Discovery Tools/Skills
  mcpTools: [String!]!
  a2aSkills: [String!]!
  
  # Image/Avatar
  image: String
  
  metadataUpdates: [AgentMetadata!]! @derivedFrom(field: "agent")
  stakes: [RegistryStake!]! @derivedFrom(field: "agent")
  tagUpdates: [TagUpdate!]! @derivedFrom(field: "agent")
  banEvents: [AgentBanEvent!]! @derivedFrom(field: "agent")
  slashEvents: [AgentSlashEvent!]! @derivedFrom(field: "agent")
  stakeEvents: [AgentStakeEvent!]! @derivedFrom(field: "agent")
  feedback: [AgentFeedback!]! @derivedFrom(field: "agent")
  validations: [AgentValidation!]! @derivedFrom(field: "agent")
}

# Tag index for efficient tag-based queries
type TagIndex @entity {
  id: ID! # tag name
  tag: String! @unique @index
  agentCount: Int!
  lastUpdated: DateTime! @index
  # Note: agents are looked up via RegisteredAgent.tags array
}

type RegistryStake @entity {
  id: ID!
  agent: RegisteredAgent!
  token: String!
  amount: BigInt!
  depositedAt: BigInt!
  txHash: String!
  blockNumber: Int!
}

type AgentMetadata @entity {
  id: ID!
  agent: RegisteredAgent!
  key: String!
  value: String!
  updatedAt: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

type TagUpdate @entity {
  id: ID!
  agent: RegisteredAgent!
  oldTags: [String!]!
  newTags: [String!]!
  updatedAt: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

type AgentBanEvent @entity {
  id: ID!
  agent: RegisteredAgent!
  isBan: Boolean! # true = ban, false = unban
  banType: String! # "network" or "app"
  appId: String # For app-specific bans
  reason: String
  proposalId: String
  timestamp: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

type AgentSlashEvent @entity {
  id: ID!
  agent: RegisteredAgent!
  slashAmount: BigInt!
  reason: String!
  timestamp: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

type AgentStakeEvent @entity {
  id: ID!
  agent: RegisteredAgent!
  eventType: String! # "increase", "withdraw"
  oldTier: Int
  newTier: Int
  amount: BigInt!
  token: String!
  timestamp: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

type AgentFeedback @entity {
  id: ID!
  agent: RegisteredAgent!
  client: Account!
  score: Int!
  tag1: String
  tag2: String
  fileUri: String
  fileHash: String
  isRevoked: Boolean!
  timestamp: DateTime! @index
  txHash: String!
  blockNumber: Int!
  responses: [FeedbackResponse!]! @derivedFrom(field: "feedback")
}

type FeedbackResponse @entity {
  id: ID!
  feedback: AgentFeedback!
  responder: Account!
  responseUri: String!
  responseHash: String
  timestamp: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

type AgentValidation @entity {
  id: ID!
  agent: RegisteredAgent!
  validator: Account!
  requestUri: String!
  requestHash: String!
  response: Int # 0-100, null if pending
  responseUri: String
  responseHash: String
  tag: String
  status: String! # "pending", "responded"
  requestedAt: DateTime! @index
  respondedAt: DateTime
  requestTxHash: String!
  responseTxHash: String
  blockNumber: Int!
}

# ============ Prediction Market Entities ============

type PredictionMarket @entity {
  id: ID! # sessionId (bytes32)
  sessionId: String! @unique @index
  question: String!
  liquidityB: BigInt!
  yesShares: BigInt!
  noShares: BigInt!
  totalVolume: BigInt!
  createdAt: DateTime! @index
  resolved: Boolean! @index
  outcome: Boolean
  
  # Relations
  trades: [MarketTrade!]! @derivedFrom(field: "market")
  positions: [MarketPosition!]! @derivedFrom(field: "market")
}

type MarketTrade @entity {
  id: ID! # txHash-logIndex
  market: PredictionMarket!
  trader: Account!
  outcome: Boolean!
  isBuy: Boolean!
  shares: BigInt!
  cost: BigInt!
  priceAfter: BigInt!
  timestamp: DateTime! @index
}

type MarketPosition @entity {
  id: ID! # marketId-traderId
  market: PredictionMarket!
  trader: Account!
  yesShares: BigInt!
  noShares: BigInt!
  totalSpent: BigInt!
  totalReceived: BigInt!
  hasClaimed: Boolean!
  lastUpdated: DateTime! @index
}

type OracleGame @entity {
  id: ID! # sessionId (bytes32)
  sessionId: String! @unique @index
  question: String!
  commitment: String!
  committedAt: DateTime! @index
  finalized: Boolean! @index
  revealedAt: DateTime
  outcome: Boolean
  winners: [String!]!
  totalPayout: BigInt!
  market: PredictionMarket
}

type MarketStats @entity {
  id: ID! # Date string
  date: DateTime! @index
  totalMarkets: BigInt!
  activeMarkets: BigInt!
  resolvedMarkets: BigInt!
  totalVolume: BigInt!
  totalTrades: BigInt!
  uniqueTraders: BigInt!
}

# ============ Jeju Oracle Network (JON) Entities ============

type OracleFeed @entity {
  id: ID! # feedId (bytes32)
  feedId: String! @unique @index
  symbol: String! @index
  baseToken: String!
  quoteToken: String!
  decimals: Int!
  heartbeatSeconds: Int!
  category: OracleFeedCategory!
  isActive: Boolean! @index
  minOracles: Int!
  quorumThreshold: Int!
  
  createdAt: DateTime! @index
  createdTxHash: String!
  lastUpdated: DateTime! @index
  
  latestPrice: BigInt
  latestConfidence: BigInt
  latestTimestamp: DateTime
  latestRound: BigInt
  
  totalReports: Int!
  totalDisputes: Int!
  
  reports: [OracleReport!]! @derivedFrom(field: "feed")
  disputes: [OracleDispute!]! @derivedFrom(field: "feed")
  committee: [OracleCommitteeMember!]! @derivedFrom(field: "feed")
}

enum OracleFeedCategory {
  SPOT_PRICE
  TWAP
  FX_RATE
  STABLECOIN_PEG
  LST_RATE
  L2_GAS
  SEQUENCER_UPTIME
  FINALITY
  MARKET_STATUS
}

type OracleReport @entity {
  id: ID! # reportId (bytes32)
  reportId: String! @unique @index
  feed: OracleFeed!
  round: BigInt! @index
  
  price: BigInt!
  confidence: BigInt!
  timestamp: DateTime! @index
  
  signers: [String!]!
  signatureCount: Int!
  
  isDisputed: Boolean! @index
  isValid: Boolean!
  
  submittedAt: DateTime! @index
  submittedBy: Account!
  txHash: String!
  blockNumber: Int! @index
  
  dispute: OracleDispute
}

type OracleDispute @entity {
  id: ID! # disputeId (bytes32)
  disputeId: String! @unique @index
  report: OracleReport!
  feed: OracleFeed!
  
  disputer: Account!
  bond: BigInt!
  reason: String!
  
  status: OracleDisputeStatus! @index
  challengeBond: BigInt
  challenger: Account
  
  openedAt: DateTime! @index
  challengeDeadline: DateTime!
  resolvedAt: DateTime
  
  outcome: OracleDisputeOutcome
  slashedAmount: BigInt
  
  txHash: String!
  blockNumber: Int! @index
}

enum OracleDisputeStatus {
  OPEN
  CHALLENGED
  RESOLVED
  EXPIRED
  ESCALATED
}

enum OracleDisputeOutcome {
  VALID
  INVALID
  PENDING
}

type OracleOperator @entity {
  id: ID! # operator address
  address: String! @unique @index
  identityId: BigInt @index
  
  isActive: Boolean! @index
  isJailed: Boolean! @index
  
  stakedAmount: BigInt!
  delegatedAmount: BigInt!
  totalSlashed: BigInt!
  
  reportsSubmitted: Int!
  reportsAccepted: Int!
  disputesAgainst: Int!
  disputesLost: Int!
  
  participationScore: Int! # 0-10000 bps
  accuracyScore: Int! # 0-10000 bps
  uptimeScore: Int! # 0-10000 bps
  
  totalEarnings: BigInt!
  pendingRewards: BigInt!
  
  registeredAt: DateTime! @index
  lastActiveAt: DateTime! @index
  
  committees: [OracleCommitteeMember!]! @derivedFrom(field: "operator")
  attestations: [OracleAttestation!]! @derivedFrom(field: "operator")
}

type OracleCommitteeMember @entity {
  id: ID! # feedId-operatorAddress
  feed: OracleFeed!
  operator: OracleOperator!
  
  isActive: Boolean! @index
  addedAt: DateTime! @index
  removedAt: DateTime
  
  reportsInFeed: Int!
  lastReportAt: DateTime
}

type OracleSubscription @entity {
  id: ID! # subscriptionId
  subscriptionId: BigInt! @unique @index
  subscriber: Account!
  
  feedIds: [String!]! # Array of feed IDs (bytes32 as hex strings)
  
  startTime: DateTime! @index
  endTime: DateTime! @index
  monthsPaid: Int!
  totalPaid: BigInt!
  
  isActive: Boolean! @index
  cancelledAt: DateTime
  
  createdAt: DateTime! @index
  txHash: String!
}

type OracleAttestation @entity {
  id: ID! # epoch-operator
  operator: OracleOperator!
  epoch: BigInt! @index
  
  feedsServed: Int!
  reportsSubmitted: Int!
  reportsAccepted: Int!
  disputesReceived: Int!
  
  participationScore: Int!
  accuracyScore: Int!
  
  attestedAt: DateTime! @index
  txHash: String!
}

type OracleNetworkStats @entity {
  id: ID! # "global" or date string
  date: DateTime @index
  
  totalFeeds: Int!
  activeFeeds: Int!
  totalOperators: Int!
  activeOperators: Int!
  
  totalReportsToday: Int!
  totalDisputesToday: Int!
  disputeRate: Int! # bps
  
  totalStaked: BigInt!
  totalFeesCollected: BigInt!
  feesToday: BigInt!
  
  avgParticipationScore: Int!
  avgAccuracyScore: Int!
  
  lastUpdated: DateTime!
}

# ============ EIL (Ethereum Interop Layer) Entities ============

type XLP @entity {
  id: ID! # XLP address
  address: String! @unique @index
  stakedAmount: BigInt!
  unbondingAmount: BigInt!
  unbondingStartTime: BigInt
  slashedAmount: BigInt!
  isActive: Boolean! @index
  registeredAt: DateTime! @index
  supportedChains: [Int!]!
  
  # Performance metrics
  totalVouchersIssued: Int!
  totalVouchersFulfilled: Int!
  totalVouchersFailed: Int!
  totalFeesEarned: BigInt!
  averageResponseTimeMs: Int!
  reputation: Int! @index # 0-100
  
  # Liquidity
  liquidityDeposits: [XLPLiquidityDeposit!]! @derivedFrom(field: "xlp")
  vouchersIssued: [CrossChainVoucher!]! @derivedFrom(field: "xlp")
}

type XLPLiquidityDeposit @entity {
  id: ID! # xlp-token-chainId
  xlp: XLP!
  token: String! @index
  chainId: Int! @index
  amount: BigInt!
  ethAmount: BigInt!
  lastUpdated: DateTime! @index
}

type CrossChainVoucherRequest @entity {
  id: ID! # requestId (bytes32)
  requestId: String! @unique @index
  requester: Account!
  sourceChain: Int! @index
  destinationChain: Int! @index
  sourceToken: String! @index
  destinationToken: String!
  amount: BigInt!
  maxFee: BigInt!
  currentFee: BigInt!
  feeIncrement: BigInt!
  recipient: String!
  gasOnDestination: BigInt!
  deadline: BigInt!
  createdAt: DateTime! @index
  createdBlock: BigInt!
  
  status: VoucherRequestStatus! @index
  claimed: Boolean!
  expired: Boolean!
  refunded: Boolean!
  
  voucher: CrossChainVoucher
}

enum VoucherRequestStatus {
  PENDING
  CLAIMED
  FULFILLED
  EXPIRED
  REFUNDED
}

type CrossChainVoucher @entity {
  id: ID! # voucherId (bytes32)
  voucherId: String! @unique @index
  request: CrossChainVoucherRequest!
  xlp: XLP!
  
  sourceChainId: Int!
  destinationChainId: Int!
  sourceToken: String!
  destinationToken: String!
  amount: BigInt!
  fee: BigInt!
  gasProvided: BigInt!
  
  issuedAt: DateTime! @index
  issuedBlock: BigInt!
  expiresBlock: BigInt!
  
  status: VoucherStatus! @index
  fulfilled: Boolean!
  slashed: Boolean!
  
  # Transaction hashes
  sourceClaimTx: String
  destinationFulfillTx: String
  fulfillmentTime: DateTime
}

enum VoucherStatus {
  ISSUED
  FULFILLED
  EXPIRED
  SLASHED
}

type EILTransfer @entity {
  id: ID! # unique transfer ID
  user: Account!
  
  sourceChain: Int! @index
  destinationChain: Int! @index
  sourceToken: String!
  destinationToken: String!
  amount: BigInt!
  fee: BigInt!
  
  xlp: XLP
  request: CrossChainVoucherRequest
  voucher: CrossChainVoucher
  
  status: TransferStatus! @index
  initiatedAt: DateTime! @index
  completedAt: DateTime
  
  sourceTxHash: String!
  destinationTxHash: String
}

enum TransferStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  REFUNDED
}

type XLPSlashEvent @entity {
  id: ID!
  xlp: XLP!
  voucherId: String! @index
  chainId: Int!
  amount: BigInt!
  victim: String!
  timestamp: DateTime! @index
  disputed: Boolean!
  txHash: String!
}

type EILStats @entity {
  id: ID! # "global" or date string for daily stats
  date: DateTime @index
  
  totalVolumeUsd: BigInt!
  totalTransactions: BigInt!
  totalXLPs: Int!
  activeXLPs: Int!
  totalStakedEth: BigInt!
  
  averageFeePercent: Int! # basis points
  averageTimeSeconds: Int!
  successRate: Int! # 0-100
  
  last24hVolume: BigInt!
  last24hTransactions: BigInt!
}

type EILChainStats @entity {
  id: ID! # chainId
  chainId: Int! @unique @index
  chainName: String!
  
  paymasterAddress: String!
  totalVolume: BigInt!
  totalTransfers: BigInt!
  activeXLPs: Int!
  totalLiquidity: BigInt!
  
  lastUpdated: DateTime! @index
}

# ============ OIF (Open Intents Framework) Entities ============

type OIFIntent @entity {
  id: ID! # intentId (bytes32)
  intentId: String! @unique @index
  user: Account!
  nonce: BigInt!
  sourceChainId: Int! @index
  
  # Deadlines
  openDeadline: BigInt!
  fillDeadline: BigInt!
  
  # Input details
  inputToken: String! @index
  inputAmount: BigInt!
  
  # Output details
  outputToken: String!
  outputAmount: BigInt!
  outputChainId: Int! @index
  recipient: String! @index
  
  # Fee
  maxFee: BigInt!
  actualFee: BigInt
  
  # Status tracking
  status: OIFIntentStatus! @index
  createdAt: DateTime! @index
  claimedAt: DateTime
  filledAt: DateTime
  settledAt: DateTime
  expiredAt: DateTime
  
  # Execution
  solver: OIFSolver
  settlement: OIFSettlement
  
  # Transaction hashes
  inputSettlerTx: String!
  outputSettlerTx: String
  attestationTx: String
  claimTx: String
  
  createdBlock: BigInt!
  filledBlock: BigInt
  
  # Quote that was accepted
  acceptedQuote: OIFQuote
}

enum OIFIntentStatus {
  OPEN
  CLAIMED
  PENDING_FILL
  FILLED
  PENDING_SETTLEMENT
  SETTLED
  EXPIRED
  CANCELLED
  FAILED
}

type OIFSolver @entity {
  id: ID! # solver address
  address: String! @unique @index
  name: String
  endpoint: String # A2A endpoint URL
  
  # Staking
  stakedAmount: BigInt!
  unbondingAmount: BigInt!
  unbondingStartTime: BigInt
  slashedAmount: BigInt!
  
  # Status
  isActive: Boolean! @index
  registeredAt: DateTime! @index
  lastActiveAt: DateTime! @index
  
  # Supported chains
  supportedChains: [Int!]!
  
  # Performance metrics
  totalFills: Int!
  successfulFills: Int!
  failedFills: Int!
  successRate: Int! # 0-100
  averageResponseMs: Int!
  averageFillTimeMs: Int!
  
  # Volume
  totalVolumeUsd: BigInt!
  totalFeesEarned: BigInt!
  
  # Reputation (0-100)
  reputation: Int! @index
  
  # Relations
  liquidity: [OIFSolverLiquidity!]! @derivedFrom(field: "solver")
  fills: [OIFIntent!]! @derivedFrom(field: "solver")
  settlements: [OIFSettlement!]! @derivedFrom(field: "solver")
  slashEvents: [OIFSlashEvent!]! @derivedFrom(field: "solver")
}

type OIFSolverLiquidity @entity {
  id: ID! # solver-chainId-token
  solver: OIFSolver!
  chainId: Int! @index
  token: String! @index
  amount: BigInt!
  lockedAmount: BigInt! # In pending fills
  lastUpdated: DateTime! @index
}

type OIFRoute @entity {
  id: ID! # routeId (sourceChain-destChain-oracle)
  routeId: String! @unique @index
  
  sourceChainId: Int! @index
  destinationChainId: Int! @index
  
  inputSettler: String!
  outputSettler: String!
  
  # Oracle configuration
  oracle: OIFOracleType!
  oracleAddress: String
  
  # Status
  isActive: Boolean! @index
  
  # Metrics
  totalVolume: BigInt!
  totalVolumeUsd: BigInt!
  totalIntents: Int!
  successfulIntents: Int!
  failedIntents: Int!
  averageFeePercent: Int! # basis points
  averageFillTimeSeconds: Int!
  successRate: Int! # 0-100
  
  # Solvers serving this route
  activeSolvers: Int!
  totalLiquidity: BigInt!
  
  createdAt: DateTime! @index
  lastUpdated: DateTime! @index
}

enum OIFOracleType {
  HYPERLANE
  OPTIMISM_NATIVE
  SUPERCHAIN
  LAYERZERO
  SIMPLE
  CUSTOM
}

type OIFSettlement @entity {
  id: ID! # settlementId (bytes32)
  settlementId: String! @unique @index
  
  intent: OIFIntent!
  solver: OIFSolver!
  
  # Details
  sourceChainId: Int!
  destinationChainId: Int!
  inputToken: String!
  outputToken: String!
  inputAmount: BigInt!
  outputAmount: BigInt!
  fee: BigInt!
  
  # Status
  status: OIFSettlementStatus! @index
  
  # Timing
  createdAt: DateTime! @index
  attestedAt: DateTime
  settledAt: DateTime
  
  # Transactions
  inputSettlerTx: String!
  outputSettlerTx: String!
  attestationTx: String
  claimTx: String
  
  # Attestation
  attestation: OIFAttestation
}

enum OIFSettlementStatus {
  PENDING
  ATTESTED
  SETTLED
  DISPUTED
  SLASHED
}

type OIFAttestation @entity {
  id: ID! # attestationId (bytes32)
  attestationId: String! @unique @index
  
  intent: OIFIntent!
  orderId: String! @index
  
  # Oracle info
  oracleType: OIFOracleType!
  sourceChainId: Int!
  destinationChainId: Int!
  
  # Proof
  proof: String!
  proofBlockNumber: BigInt!
  proofTimestamp: DateTime!
  
  # Verification
  verified: Boolean!
  verifiedAt: DateTime
  verificationTx: String
  
  settlement: OIFSettlement
}

type OIFQuote @entity {
  id: ID! # quoteId
  quoteId: String! @unique @index
  
  # Route
  sourceChainId: Int! @index
  destinationChainId: Int! @index
  sourceToken: String!
  destinationToken: String!
  
  # Amounts
  inputAmount: BigInt!
  outputAmount: BigInt!
  
  # Pricing
  fee: BigInt!
  feePercent: Int! # basis points
  priceImpact: Int! # basis points
  
  # Timing
  estimatedFillTimeSeconds: Int!
  validUntil: DateTime!
  
  # Solver
  solver: OIFSolver!
  solverReputation: Int!
  
  # Status
  accepted: Boolean!
  expired: Boolean!
  
  createdAt: DateTime! @index
}

type OIFSlashEvent @entity {
  id: ID!
  solver: OIFSolver!
  intentId: String! @index
  orderId: String!
  chainId: Int!
  amount: BigInt!
  victim: String!
  reason: String!
  timestamp: DateTime! @index
  disputed: Boolean!
  txHash: String!
}

type OIFStats @entity {
  id: ID! # "global" or date string for daily stats
  date: DateTime @index
  
  # Intent counts
  totalIntents: BigInt!
  openIntents: Int!
  pendingIntents: Int!
  filledIntents: Int!
  expiredIntents: Int!
  
  # Volume
  totalVolume: BigInt!
  totalVolumeUsd: BigInt!
  totalFees: BigInt!
  totalFeesUsd: BigInt!
  
  # Solvers
  totalSolvers: Int!
  activeSolvers: Int!
  totalSolverStake: BigInt!
  
  # Routes
  totalRoutes: Int!
  activeRoutes: Int!
  
  # Performance
  averageFillTimeSeconds: Int!
  successRate: Int! # 0-100
  
  # 24h metrics
  last24hIntents: Int!
  last24hVolume: BigInt!
  last24hFees: BigInt!
  
  lastUpdated: DateTime!
}

type OIFChainStats @entity {
  id: ID! # chainId
  chainId: Int! @unique @index
  chainName: String!
  
  inputSettlerAddress: String!
  outputSettlerAddress: String!
  solverRegistryAddress: String
  
  # Metrics
  totalIntents: Int!
  totalVolume: BigInt!
  totalVolumeUsd: BigInt!
  activeSolvers: Int!
  totalLiquidity: BigInt!
  
  # As source
  outboundIntents: Int!
  outboundVolume: BigInt!
  
  # As destination
  inboundIntents: Int!
  inboundVolume: BigInt!
  
  lastUpdated: DateTime! @index
}

# ============ Compute Infrastructure Entities ============

type ComputeProvider @entity {
  id: ID! # provider address
  address: String! @unique @index
  name: String # Provider name
  endpoint: String!
  attestationHash: String # TEE/GPU attestation hash
  stakeAmount: BigInt!
  agentId: Int # ERC-8004 agent ID
  isActive: Boolean! @index
  registeredAt: DateTime! @index
  lastUpdated: DateTime! @index
  totalRentals: Int!
  totalEarnings: BigInt!
  
  # Relations
  resources: [ComputeResource!]! @derivedFrom(field: "provider")
  rentals: [ComputeRental!]! @derivedFrom(field: "provider")
  inferenceRequests: [InferenceRequest!]! @derivedFrom(field: "provider")
}

type ComputeResource @entity {
  id: ID! # provider-resourceId
  provider: ComputeProvider!
  resourceId: String! @index
  gpuCount: Int!
  cpuCores: Int!
  memoryGB: Int!
  pricePerHour: BigInt!
  isAvailable: Boolean! @index
  createdAt: DateTime! @index
  
  rentals: [ComputeRental!]! @derivedFrom(field: "resource")
}

type ComputeRental @entity {
  id: ID! # rentalId
  rentalId: String! @unique @index
  renter: Account!
  provider: ComputeProvider!
  resource: ComputeResource
  duration: BigInt!
  price: BigInt!
  status: ComputeRentalStatus! @index
  startTime: DateTime
  endTime: DateTime
  createdAt: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

enum ComputeRentalStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
}

type InferenceRequest @entity {
  id: ID! # requestId
  requestId: String! @unique @index
  requester: Account!
  provider: ComputeProvider!
  model: String! @index
  maxTokens: BigInt!
  tokensUsed: BigInt
  status: InferenceStatus! @index
  responseHash: String
  createdAt: DateTime! @index
  completedAt: DateTime
  txHash: String!
  blockNumber: Int!
}

enum InferenceStatus {
  PENDING
  COMPLETED
  DISPUTED
  SETTLED
}

type ComputeLedgerBalance @entity {
  id: ID! # account-token
  account: Account!
  token: String! @index
  balance: BigInt!
  lockedAmount: BigInt!
  lastUpdated: DateTime! @index
}

type ComputeStats @entity {
  id: ID! # "global" or date string
  date: DateTime @index
  
  totalProviders: Int!
  activeProviders: Int!
  totalResources: Int!
  availableResources: Int!
  totalRentals: Int!
  activeRentals: Int!
  completedRentals: Int!
  totalInferenceRequests: Int!
  
  totalStaked: BigInt!
  totalEarnings: BigInt!
  
  last24hRentals: Int!
  last24hInference: Int!
  
  lastUpdated: DateTime!
}

# ============ Storage Infrastructure Entities ============

type StorageProvider @entity {
  id: ID! # provider address
  address: String! @unique @index
  name: String!
  endpoint: String!
  providerType: StorageProviderType! @index
  attestationHash: String
  stakeAmount: BigInt!
  agentId: Int # ERC-8004 agent ID
  isActive: Boolean! @index
  isVerified: Boolean!
  registeredAt: DateTime! @index
  lastUpdated: DateTime! @index
  
  # Capacity
  totalCapacityGB: BigInt!
  usedCapacityGB: BigInt!
  availableCapacityGB: BigInt!
  
  # Pricing (wei per GB per month)
  pricePerGBMonth: BigInt!
  uploadPricePerGB: BigInt!
  retrievalPricePerGB: BigInt!
  minStoragePeriodDays: Int!
  maxStoragePeriodDays: Int!
  
  # Performance
  healthScore: Int!
  avgLatencyMs: Int!
  replicationFactor: Int!
  ipfsGateway: String
  supportedTiers: [StorageTier!]!
  
  # Stats
  totalDeals: Int!
  activeDeals: Int!
  completedDeals: Int!
  failedDeals: Int!
  totalStoredGB: BigInt!
  totalEarnings: BigInt!
  avgRating: Int! # 0-100
  ratingCount: Int!
  uptimePercent: Int!
  
  # Relations
  deals: [StorageDeal!]! @derivedFrom(field: "provider")
}

enum StorageProviderType {
  IPFS_NODE
  FILECOIN
  ARWEAVE
  CLOUD_S3
  CLOUD_VERCEL
  CLOUD_R2
  HYBRID
}

enum StorageTier {
  HOT
  WARM
  COLD
  PERMANENT
}

type StorageDeal @entity {
  id: ID! # dealId
  dealId: String! @unique @index
  user: Account!
  provider: StorageProvider!
  status: StorageDealStatus! @index
  cid: String! @index
  sizeBytes: BigInt!
  tier: StorageTier! @index
  startTime: DateTime
  endTime: DateTime
  totalCost: BigInt!
  paidAmount: BigInt!
  refundedAmount: BigInt!
  replicationFactor: Int!
  retrievalCount: Int!
  createdAt: DateTime! @index
  txHash: String!
  blockNumber: Int!
  
  # Rating
  rating: Int # 0-100
  ratingComment: String
}

enum StorageDealStatus {
  PENDING
  ACTIVE
  EXPIRED
  TERMINATED
  FAILED
  DISPUTED
}

type StorageLedgerBalance @entity {
  id: ID! # user-provider
  user: Account!
  provider: StorageProvider
  totalBalance: BigInt!
  availableBalance: BigInt!
  lockedBalance: BigInt!
  pendingRefund: BigInt!
  refundUnlockTime: DateTime
  lastUpdated: DateTime! @index
}

type StorageMarketStats @entity {
  id: ID! # "global" or date string
  date: DateTime @index
  
  totalProviders: Int!
  activeProviders: Int!
  verifiedProviders: Int!
  totalCapacityTB: BigInt!
  usedCapacityTB: BigInt!
  
  totalDeals: Int!
  activeDeals: Int!
  completedDeals: Int!
  
  totalStaked: BigInt!
  totalEarnings: BigInt!
  avgPricePerGBMonth: BigInt!
  
  last24hDeals: Int!
  last24hVolume: BigInt!
  
  lastUpdated: DateTime!
}

# ============ Cross-Service Integration Entities ============

type ContainerImage @entity {
  id: ID! # CID
  cid: String! @unique @index
  name: String!
  tag: String!
  sizeBytes: BigInt!
  uploadedAt: DateTime! @index
  uploadedBy: Account!
  
  # Storage info
  storageProvider: StorageProvider
  storageDeal: StorageDeal
  tier: StorageTier! @index
  expiresAt: DateTime
  
  # Compute compatibility
  architecture: ContainerArchitecture! @index
  gpuRequired: Boolean! @index
  minGpuVram: Int
  teeRequired: Boolean! @index
  
  # Verification
  contentHash: String!
  verified: Boolean! @index
  verifiedBy: RegisteredAgent
  
  # Usage tracking
  pullCount: Int!
  lastPulledAt: DateTime
  
  # Relations
  crossServiceRequests: [CrossServiceRequest!]! @derivedFrom(field: "containerImage")
}

enum ContainerArchitecture {
  AMD64
  ARM64
  MULTI
}

type CrossServiceRequest @entity {
  id: ID! # requestId
  requestId: String! @unique @index
  requester: Account!
  requestType: CrossServiceRequestType! @index
  
  # Source (storage)
  containerImage: ContainerImage
  sourceCid: String! @index
  sourceProvider: StorageProvider
  
  # Destination (compute)
  destinationProvider: ComputeProvider
  destinationRental: ComputeRental
  
  # Status
  status: CrossServiceRequestStatus! @index
  createdAt: DateTime! @index
  completedAt: DateTime
  
  # Cost breakdown
  storageCost: BigInt!
  bandwidthCost: BigInt!
  totalCost: BigInt!
  
  # Result
  error: String
  txHash: String!
  blockNumber: Int! @index
}

enum CrossServiceRequestType {
  CONTAINER_PULL
  DATA_LOAD
  MODEL_FETCH
  OUTPUT_STORE
}

enum CrossServiceRequestStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

type MarketplaceStats @entity {
  id: ID! # "global" or date string
  date: DateTime @index
  
  # Compute metrics
  computeProviders: Int!
  activeComputeProviders: Int!
  computeAgentLinked: Int!
  totalComputeRentals: Int!
  activeComputeRentals: Int!
  computeStaked: BigInt!
  computeEarnings: BigInt!
  
  # Storage metrics
  storageProviders: Int!
  activeStorageProviders: Int!
  storageAgentLinked: Int!
  totalStorageDeals: Int!
  activeStorageDeals: Int!
  storageCapacityTB: BigInt!
  storageUsedTB: BigInt!
  storageStaked: BigInt!
  
  # Cross-service metrics
  totalContainerImages: Int!
  verifiedContainerImages: Int!
  totalCrossServiceRequests: Int!
  successfulRequests: Int!
  fullStackAgents: Int!
  
  # 24h metrics
  last24hContainerPulls: Int!
  last24hCrossServiceVolume: BigInt!
  
  lastUpdated: DateTime!
}

# ============ JNS (Jeju Name Service) Entities ============

type JNSName @entity {
  id: ID! # node hash
  name: String! @index
  labelhash: String! @index
  node: String! @unique @index
  
  # Ownership
  owner: Account! @index
  resolver: String
  
  # Registration
  registeredAt: DateTime! @index
  expiresAt: DateTime! @index
  registrationCost: BigInt!
  
  # Status
  isExpired: Boolean! @index
  inGracePeriod: Boolean!
  
  # Resolver records
  resolvedAddress: String
  contenthash: String
  
  # ERC-8004 Integration
  linkedAgentId: BigInt
  linkedAgent: RegisteredAgent
  
  # App configuration
  appContract: String
  appId: String
  appEndpoint: String
  appA2AEndpoint: String
  
  # Text records (stored as JSON)
  textRecords: JSON
  
  # Marketplace
  isListed: Boolean!
  currentListing: JNSListing
  
  # Stats
  transferCount: Int!
  renewalCount: Int!
  
  # Metadata
  createdAt: DateTime! @index
  lastUpdated: DateTime! @index
  
  # Relations
  transfers: [JNSTransfer!]! @derivedFrom(field: "name")
  renewals: [JNSRenewal!]! @derivedFrom(field: "name")
  listings: [JNSListing!]! @derivedFrom(field: "name")
}

type JNSTransfer @entity {
  id: ID! # tx-logIndex
  name: JNSName!
  from: Account!
  to: Account!
  timestamp: DateTime! @index
  txHash: String!
  blockNumber: Int! @index
}

type JNSRenewal @entity {
  id: ID! # tx-logIndex
  name: JNSName!
  renewer: Account!
  cost: BigInt!
  newExpiresAt: DateTime!
  timestamp: DateTime! @index
  txHash: String!
  blockNumber: Int! @index
}

type JNSListing @entity {
  id: ID! # listingId
  name: JNSName!
  seller: Account!
  price: BigInt!
  currency: String! # ETH, HG, USDC
  
  status: JNSListingStatus!
  createdAt: DateTime! @index
  expiresAt: DateTime
  soldAt: DateTime
  buyer: Account
  
  txHash: String!
  blockNumber: Int! @index
}

enum JNSListingStatus {
  ACTIVE
  SOLD
  CANCELLED
  EXPIRED
}

type JNSResolverRecord @entity {
  id: ID! # node-key
  name: JNSName!
  key: String! @index
  value: String!
  timestamp: DateTime! @index
  txHash: String!
}

type JNSReverseRecord @entity {
  id: ID! # address
  address: String! @unique @index
  name: JNSName
  primaryName: String
  timestamp: DateTime! @index
  txHash: String!
}

type JNSStats @entity {
  id: ID! # "global" or date string
  date: DateTime @index
  
  totalNames: Int!
  activeNames: Int!
  expiredNames: Int!
  
  totalOwners: Int!
  totalRevenue: BigInt!
  
  registrationsToday: Int!
  renewalsToday: Int!
  transfersToday: Int!
  
  floorPrice: BigInt!
  avgSalePrice: BigInt!
  totalListings: Int!
  activeListings: Int!
  
  lastUpdated: DateTime!
}

# ============ Perpetual Futures DEX Entities ============

type PerpMarket @entity {
  id: ID! # marketId (bytes32)
  marketId: String! @unique @index
  symbol: String! @index
  oracleAsset: String!
  settlementToken: String
  
  maxLeverage: Int!
  maintenanceMarginBps: Int!
  liquidationFeeBps: Int!
  makerFeeBps: Int!
  takerFeeBps: Int!
  maxOpenInterest: BigInt!
  
  isActive: Boolean! @index
  createdAt: DateTime! @index
  createdTxHash: String!
  
  # Current state
  markPrice: BigInt!
  indexPrice: BigInt!
  fundingRate: BigInt!
  lastFundingTime: DateTime!
  
  longOpenInterest: BigInt!
  shortOpenInterest: BigInt!
  
  # Stats
  totalVolume: BigInt!
  totalTrades: Int!
  totalLiquidations: Int!
  totalFundingPaid: BigInt!
  
  # Relations
  positions: [PerpPosition!]! @derivedFrom(field: "market")
  trades: [PerpTrade!]! @derivedFrom(field: "market")
  liquidations: [PerpLiquidation!]! @derivedFrom(field: "market")
  fundingPayments: [PerpFundingPayment!]! @derivedFrom(field: "market")
}

enum PerpPositionSide {
  LONG
  SHORT
}

enum PerpPositionStatus {
  OPEN
  CLOSED
  LIQUIDATED
}

type PerpPosition @entity {
  id: ID! # positionId (bytes32)
  positionId: String! @unique @index
  market: PerpMarket!
  trader: Account!
  
  side: PerpPositionSide! @index
  status: PerpPositionStatus! @index
  
  size: BigInt!
  margin: BigInt!
  marginToken: String!
  entryPrice: BigInt!
  leverage: Int!
  
  # Current state (updated on price changes)
  markPrice: BigInt!
  unrealizedPnl: BigInt!
  liquidationPrice: BigInt!
  healthFactor: BigInt!
  
  # Cumulative
  realizedPnl: BigInt!
  fundingPaid: BigInt!
  feePaid: BigInt!
  
  openedAt: DateTime! @index
  closedAt: DateTime
  openTxHash: String!
  closeTxHash: String
  
  # Relations
  trades: [PerpTrade!]! @derivedFrom(field: "position")
  fundingPayments: [PerpFundingPayment!]! @derivedFrom(field: "position")
}

enum PerpTradeType {
  OPEN
  INCREASE
  DECREASE
  CLOSE
}

type PerpTrade @entity {
  id: ID! # txHash-logIndex
  market: PerpMarket!
  position: PerpPosition
  trader: Account!
  
  tradeType: PerpTradeType! @index
  side: PerpPositionSide!
  
  size: BigInt!
  price: BigInt!
  margin: BigInt!
  marginToken: String!
  leverage: Int!
  
  fee: BigInt!
  realizedPnl: BigInt!
  
  timestamp: DateTime! @index
  txHash: String! @index
  blockNumber: Int! @index
}

type PerpLiquidation @entity {
  id: ID! # txHash-logIndex
  market: PerpMarket!
  position: PerpPosition!
  
  liquidator: Account!
  trader: Account!
  
  size: BigInt!
  margin: BigInt!
  liquidationPrice: BigInt!
  markPrice: BigInt!
  
  liquidatorReward: BigInt!
  insuranceFundFee: BigInt!
  badDebt: BigInt!
  
  timestamp: DateTime! @index
  txHash: String! @index
  blockNumber: Int! @index
}

type PerpFundingPayment @entity {
  id: ID! # positionId-timestamp
  market: PerpMarket!
  position: PerpPosition!
  trader: Account!
  
  fundingRate: BigInt!
  payment: BigInt!
  isPayment: Boolean!
  
  positionSize: BigInt!
  
  timestamp: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

type PerpInsuranceFund @entity {
  id: ID! # token address
  token: String! @unique @index
  balance: BigInt!
  totalDeposited: BigInt!
  totalWithdrawn: BigInt!
  totalBadDebtCovered: BigInt!
  
  lastUpdated: DateTime! @index
}

type PerpCollateralDeposit @entity {
  id: ID! # txHash-logIndex
  trader: Account!
  token: String! @index
  amount: BigInt!
  
  isCrossChain: Boolean!
  sourceChainId: Int
  voucherId: String
  
  timestamp: DateTime! @index
  txHash: String! @index
  blockNumber: Int!
}

type PerpCollateralWithdrawal @entity {
  id: ID! # txHash-logIndex
  trader: Account!
  token: String! @index
  amount: BigInt!
  
  timestamp: DateTime! @index
  txHash: String! @index
  blockNumber: Int!
}

type PerpMarketStats @entity {
  id: ID! # "global" or marketId-date
  market: PerpMarket
  date: DateTime @index
  
  # Volume
  volume24h: BigInt!
  trades24h: Int!
  uniqueTraders24h: Int!
  
  # Open Interest
  longOpenInterest: BigInt!
  shortOpenInterest: BigInt!
  totalOpenInterest: BigInt!
  
  # Prices
  highPrice24h: BigInt!
  lowPrice24h: BigInt!
  openPrice24h: BigInt!
  closePrice24h: BigInt!
  
  # Funding
  fundingRate: BigInt!
  cumulativeFunding24h: BigInt!
  
  # Liquidations
  liquidations24h: Int!
  liquidationVolume24h: BigInt!
  
  # Fees
  totalFees24h: BigInt!
  insuranceFundFees24h: BigInt!
  
  lastUpdated: DateTime!
}

type PerpGlobalStats @entity {
  id: ID! # "global" or date string
  date: DateTime @index
  
  totalMarkets: Int!
  activeMarkets: Int!
  
  totalVolume: BigInt!
  volume24h: BigInt!
  
  totalTrades: Int!
  trades24h: Int!
  
  totalOpenInterest: BigInt!
  totalLongOI: BigInt!
  totalShortOI: BigInt!
  
  totalLiquidations: Int!
  liquidations24h: Int!
  
  totalFees: BigInt!
  fees24h: BigInt!
  
  totalBadDebt: BigInt!
  insuranceFundBalance: BigInt!
  
  uniqueTraders: Int!
  activeTraders24h: Int!
  
  lastUpdated: DateTime!
}

# ============ Keepalive Registry Entities ============

enum KeepaliveStatus {
  UNKNOWN
  HEALTHY
  DEGRADED
  UNHEALTHY
  UNFUNDED
}

enum KeepaliveResourceType {
  IPFS_CONTENT
  COMPUTE_ENDPOINT
  TRIGGER
  STORAGE
  AGENT
  CUSTOM
}

type Keepalive @entity {
  id: ID! # keepaliveId
  owner: Account!
  jnsNode: String! @index
  agentId: BigInt
  vaultAddress: String! @index
  globalMinBalance: BigInt!
  checkInterval: Int!
  autoFundAmount: BigInt!
  autoFundEnabled: Boolean!
  active: Boolean!
  status: KeepaliveStatus!
  createdAt: DateTime!
  lastCheckAt: DateTime
  lastHealthy: DateTime
  totalAutoFunded: BigInt!
  healthCheckCount: Int!
  resources: [KeepaliveResource!]! @derivedFrom(field: "keepalive")
  healthChecks: [KeepaliveHealthCheck!]! @derivedFrom(field: "keepalive")
}

type KeepaliveResource @entity {
  id: ID! # keepaliveId-index
  keepalive: Keepalive!
  resourceType: KeepaliveResourceType!
  identifier: String!
  healthEndpoint: String
  minBalance: BigInt!
  required: Boolean!
  addedAt: DateTime!
}

type KeepaliveHealthCheck @entity {
  id: ID! # txHash-logIndex
  keepalive: Keepalive!
  status: KeepaliveStatus!
  balance: BigInt!
  healthyResources: Int!
  totalResources: Int!
  failedResources: [String!]!
  timestamp: DateTime!
  blockNumber: Int! @index
  txHash: String! @index
}

type KeepaliveAutoFund @entity {
  id: ID! # txHash-logIndex
  keepalive: Keepalive!
  amount: BigInt!
  vault: String!
  success: Boolean!
  timestamp: DateTime!
  blockNumber: Int! @index
  txHash: String! @index
}

# ============ ENS Mirror Entities ============

type ENSMirror @entity {
  id: ID! # mirrorId
  ensNode: String! @index
  jnsNode: String! @index
  owner: Account!
  syncInterval: Int!
  mirrorContenthash: Boolean!
  mirrorAddress: Boolean!
  textKeys: [String!]!
  active: Boolean!
  createdAt: DateTime!
  lastSyncAt: DateTime
  syncCount: Int!
  lastEthBlock: BigInt
  syncs: [ENSMirrorSync!]! @derivedFrom(field: "mirror")
}

type ENSMirrorSync @entity {
  id: ID! # txHash-logIndex
  mirror: ENSMirror!
  ethBlockNumber: BigInt!
  success: Boolean!
  errorReason: String
  timestamp: DateTime!
  blockNumber: Int! @index
  txHash: String! @index
}

type KeepaliveStats @entity {
  id: ID! # "global" or date string
  date: DateTime @index
  totalKeepalives: Int!
  activeKeepalives: Int!
  healthyCount: Int!
  degradedCount: Int!
  unhealthyCount: Int!
  unfundedCount: Int!
  totalFundedValue: BigInt!
  totalAutoFunded: BigInt!
  totalHealthChecks: Int!
  mirrorCount: Int!
  syncedMirrors: Int!
  lastUpdated: DateTime!
}

# ============ Council Registry Integration Entities ============

type CompositeScoreCalculation @entity {
  id: ID! # agentId
  agentId: BigInt! @index
  stakeScore: Int!
  reputationScore: Int!
  activityScore: Int!
  violationPenalty: Int!
  compositeScore: Int!
  isBanned: Boolean!
  lastUpdated: DateTime!
}

type ProviderReputationWeight @entity {
  id: ID! # provider address
  provider: String! @index
  providerAgentId: BigInt
  stakeAmount: BigInt!
  stakeTime: DateTime
  averageReputation: Int!
  violationsReported: Int!
  operatorCount: Int!
  weightedScore: Int!
  lastUpdated: DateTime!
}

type AgentEligibility @entity {
  id: ID! # agentId
  agentId: BigInt! @index
  canSubmitProposal: Boolean!
  proposalIneligibleReason: String
  canVote: Boolean!
  voteIneligibleReason: String
  canConductResearch: Boolean!
  researchIneligibleReason: String
  checkedAt: DateTime!
}

type VotingPowerSnapshot @entity {
  id: ID! # voter-proposalId
  voter: String! @index
  agentId: BigInt
  proposalId: String @index
  baseVotes: BigInt!
  reputationMultiplier: Int!
  stakeMultiplier: Int!
  effectiveVotes: BigInt!
  snapshotAt: DateTime!
  blockNumber: Int!
}

type WeightedReputationQuery @entity {
  id: ID! # agentId-timestamp
  agentId: BigInt! @index
  weightedReputation: Int!
  totalWeight: BigInt!
  providerCount: Int!
  queriedAt: DateTime!
}

type RegistrySearchQuery @entity {
  id: ID! # query hash
  queryType: String! # "tag", "score", "top"
  queryParams: String!
  resultCount: Int!
  executionTime: Int! # milliseconds
  queriedAt: DateTime! @index
}
