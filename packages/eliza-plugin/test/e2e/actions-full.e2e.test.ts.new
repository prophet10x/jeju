// Original tests - uncomment when @elizaos/core fixes zod compatibility
import { beforeAll, afterAll } from "bun:test";
import { parseEther, type Address, type Hex } from "viem";
import {
  createJejuClient,
  type JejuClient,
} from "@jejunetwork/sdk";
import { initJejuService, getJejuService, type StandaloneJejuService } from "../../src/service";
import { setupTestEnvironment, type TestEnvironment, stopServices } from "../integration/setup";

// Import all actions
import { jejuPlugin } from "../../src/index";

// Test accounts
const DEPLOYER_KEY =
  "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" as const;
const USER_KEY =
  "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d" as const;

let env: TestEnvironment;
let service: StandaloneJejuService;
let deployer: JejuClient;

beforeAll(async () => {
  env = await setupTestEnvironment();

  service = await initJejuService({
    network: "localnet",
    privateKey: USER_KEY,
    smartAccount: false,
  });

  deployer = await createJejuClient({
    network: "localnet",
    privateKey: DEPLOYER_KEY,
    smartAccount: false,
  });

  // Fund test user from deployer
  if (env.chainRunning) {
    const balance = await service.sdk.getBalance();
    if (balance < parseEther("1")) {
      await deployer.sendTransaction({
        to: service.sdk.address,
        value: parseEther("10"),
      });
    }
  }
}, 120000);

afterAll(async () => {
  await stopServices();
});

// ═══════════════════════════════════════════════════════════════════════════
//                          PLUGIN STRUCTURE TESTS
// ═══════════════════════════════════════════════════════════════════════════

describe("Plugin Structure", () => {
  test("plugin has correct name", () => {
    expect(jejuPlugin.name).toBeDefined();
    expect(typeof jejuPlugin.name).toBe("string");
  });

  test("plugin has description", () => {
    expect(jejuPlugin.description).toBeDefined();
    expect(jejuPlugin.description.length).toBeGreaterThan(0);
  });

  test("plugin has providers", () => {
    expect(jejuPlugin.providers).toBeDefined();
    expect(Array.isArray(jejuPlugin.providers)).toBe(true);
    expect(jejuPlugin.providers!.length).toBeGreaterThan(0);
  });

  test("plugin has service", () => {
    expect(jejuPlugin.services).toBeDefined();
    expect(Array.isArray(jejuPlugin.services)).toBe(true);
  });

  test("plugin has actions", () => {
    expect(jejuPlugin.actions).toBeDefined();
    expect(Array.isArray(jejuPlugin.actions)).toBe(true);
    expect(jejuPlugin.actions!.length).toBeGreaterThan(50); // We have 85+ actions
  });

  test("all actions have required properties", () => {
    for (const action of jejuPlugin.actions!) {
      expect(action.name).toBeDefined();
      expect(action.description).toBeDefined();
      expect(action.handler).toBeDefined();
      expect(action.validate).toBeDefined();
      expect(typeof action.name).toBe("string");
      expect(typeof action.description).toBe("string");
      expect(typeof action.handler).toBe("function");
      expect(typeof action.validate).toBe("function");
    }
  });

  test("all actions have unique names", () => {
    const names = jejuPlugin.actions!.map((a) => a.name);
    const uniqueNames = new Set(names);
    expect(uniqueNames.size).toBe(names.length);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          SERVICE TESTS
// ═══════════════════════════════════════════════════════════════════════════

describe("JejuService", () => {
  test("service initializes correctly", () => {
    expect(service).toBeDefined();
    expect(service.sdk).toBeDefined();
  });

  test("service has wallet configured", () => {
    expect(service.sdk.address).toMatch(/^0x[a-fA-F0-9]{40}$/);
    expect(service.sdk.network).toBe("localnet");
  });

  test("service has all SDK modules", () => {
    expect(service.sdk.compute).toBeDefined();
    expect(service.sdk.storage).toBeDefined();
    expect(service.sdk.defi).toBeDefined();
    expect(service.sdk.governance).toBeDefined();
    expect(service.sdk.names).toBeDefined();
    expect(service.sdk.identity).toBeDefined();
    expect(service.sdk.crosschain).toBeDefined();
    expect(service.sdk.payments).toBeDefined();
    expect(service.sdk.a2a).toBeDefined();
    expect(service.sdk.games).toBeDefined();
    expect(service.sdk.containers).toBeDefined();
    expect(service.sdk.launchpad).toBeDefined();
    expect(service.sdk.moderation).toBeDefined();
    expect(service.sdk.work).toBeDefined();
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          COMPUTE ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Compute Actions", () => {
  test("LIST_PROVIDERS via SDK", async () => {
    if (!env.chainRunning) return;
    const providers = await service.sdk.compute.listProviders();
    expect(Array.isArray(providers)).toBe(true);
  });

  test("LIST_MODELS via SDK", async () => {
    if (!env.chainRunning) return;
    const models = await service.sdk.compute.listModels();
    expect(Array.isArray(models)).toBe(true);
  });

  test("LIST_MY_RENTALS via SDK", async () => {
    if (!env.chainRunning) return;
    const rentals = await service.sdk.compute.listMyRentals();
    expect(Array.isArray(rentals)).toBe(true);
  });

  test("GET_QUOTE via SDK", async () => {
    if (!env.chainRunning) return;
    const quote = await service.sdk.compute.getQuote({
      gpuType: "RTX4090",
      durationHours: 1,
    });
    expect(quote).toBeDefined();
    expect(typeof quote.totalCost).toBe("bigint");
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          STORAGE ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Storage Actions", () => {
  test("ESTIMATE_STORAGE_COST via SDK", async () => {
    if (!env.chainRunning) return;
    const cost = await service.sdk.storage.estimateCost(1024 * 1024, 30);
    expect(typeof cost).toBe("bigint");
  });

  test("UPLOAD_FILE via SDK", async () => {
    if (!env.servicesRunning) return;
    const testData = new Blob(["e2e test " + Date.now()]);
    const cid = await service.sdk.storage.upload(testData);
    expect(cid).toBeDefined();
    expect(typeof cid).toBe("string");
  });

  test("RETRIEVE_FILE via SDK", async () => {
    if (!env.servicesRunning) return;
    const testData = new Blob(["retrieve test " + Date.now()]);
    const cid = await service.sdk.storage.upload(testData);
    const retrieved = await service.sdk.storage.retrieve(cid);
    expect(retrieved).toBeDefined();
  });

  test("PIN_CID via SDK", async () => {
    if (!env.servicesRunning) return;
    const testData = new Blob(["pin test " + Date.now()]);
    const cid = await service.sdk.storage.upload(testData);
    const result = await service.sdk.storage.pin(cid);
    expect(result).toBeDefined();
  });

  test("LIST_PINS via SDK", async () => {
    if (!env.servicesRunning) return;
    const pins = await service.sdk.storage.listPins();
    expect(Array.isArray(pins)).toBe(true);
  });

  test("GET_STORAGE_STATS via SDK", async () => {
    if (!env.servicesRunning) return;
    const stats = await service.sdk.storage.getStats();
    expect(stats).toBeDefined();
    expect(typeof stats.totalSize).toBe("number");
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          DEFI ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("DeFi Actions", () => {
  test("LIST_POOLS via SDK", async () => {
    if (!env.chainRunning) return;
    const pools = await service.sdk.defi.listPools();
    expect(Array.isArray(pools)).toBe(true);
  });

  test("MY_POSITIONS via SDK", async () => {
    if (!env.chainRunning) return;
    const positions = await service.sdk.defi.listPositions();
    expect(Array.isArray(positions)).toBe(true);
  });

  test("GET_SWAP_QUOTE via SDK", async () => {
    if (!env.chainRunning) return;
    const quote = await service.sdk.defi.getSwapQuote({
      tokenIn: "0x0000000000000000000000000000000000000000" as Address,
      tokenOut: "0x0000000000000000000000000000000000000001" as Address,
      amountIn: parseEther("1"),
    });
    expect(quote).toBeDefined();
  });

  test("GET_SUPPORTED_TOKENS via SDK", async () => {
    if (!env.chainRunning) return;
    const tokens = await service.sdk.defi.getSupportedTokens();
    expect(Array.isArray(tokens)).toBe(true);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          GOVERNANCE ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Governance Actions", () => {
  test("LIST_PROPOSALS via SDK", async () => {
    if (!env.chainRunning) return;
    const proposals = await service.sdk.governance.listProposals();
    expect(Array.isArray(proposals)).toBe(true);
  });

  test("GET_VOTING_POWER via SDK", async () => {
    if (!env.chainRunning) return;
    const power = await service.sdk.governance.getVotingPower();
    expect(typeof power).toBe("bigint");
  });

  test("GET_DELEGATES via SDK", async () => {
    if (!env.chainRunning) return;
    const delegate = await service.sdk.governance.getDelegates();
    expect(delegate === null || typeof delegate === "string").toBe(true);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          NAMES ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Names (JNS) Actions", () => {
  test("CHECK_AVAILABILITY via SDK", async () => {
    if (!env.chainRunning) return;
    const available = await service.sdk.names.isAvailable("e2etest" + Date.now());
    expect(typeof available).toBe("boolean");
  });

  test("GET_REGISTRATION_COST via SDK", async () => {
    if (!env.chainRunning) return;
    const cost = await service.sdk.names.getRegistrationCost("testname", 1);
    expect(typeof cost).toBe("bigint");
  });

  test("RESOLVE_NAME via SDK", async () => {
    if (!env.chainRunning) return;
    const address = await service.sdk.names.resolve("nonexistent.jeju");
    expect(address === null || typeof address === "string").toBe(true);
  });

  test("REVERSE_RESOLVE via SDK", async () => {
    if (!env.chainRunning) return;
    const name = await service.sdk.names.reverseResolve(service.sdk.address);
    expect(name === null || typeof name === "string").toBe(true);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          IDENTITY ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Identity Actions", () => {
  test("GET_MY_AGENT via SDK", async () => {
    if (!env.chainRunning) return;
    const agent = await service.sdk.identity.getMyAgent();
    expect(agent === null || typeof agent === "object").toBe(true);
  });

  test("AM_I_BANNED via SDK", async () => {
    if (!env.chainRunning) return;
    const banned = await service.sdk.identity.amIBanned();
    expect(typeof banned).toBe("boolean");
  });

  test("LIST_AGENTS via SDK", async () => {
    if (!env.chainRunning) return;
    const agents = await service.sdk.identity.listAgents();
    expect(Array.isArray(agents)).toBe(true);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          CROSS-CHAIN ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Cross-chain Actions", () => {
  test("GET_SUPPORTED_CHAINS via SDK", async () => {
    const chains = await service.sdk.crosschain.getSupportedChains();
    expect(Array.isArray(chains)).toBe(true);
  });

  test("LIST_SOLVERS via SDK", async () => {
    if (!env.chainRunning) return;
    const solvers = await service.sdk.crosschain.listSolvers();
    expect(Array.isArray(solvers)).toBe(true);
  });

  test("LIST_XLPS via SDK", async () => {
    if (!env.chainRunning) return;
    const xlps = await service.sdk.crosschain.listXLPs();
    expect(Array.isArray(xlps)).toBe(true);
  });

  test("LIST_MY_INTENTS via SDK", async () => {
    if (!env.chainRunning) return;
    const intents = await service.sdk.crosschain.listMyIntents();
    expect(Array.isArray(intents)).toBe(true);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          PAYMENTS ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Payments Actions", () => {
  test("GET_BALANCE via SDK", async () => {
    if (!env.chainRunning) return;
    const balance = await service.sdk.payments.getBalance();
    expect(typeof balance).toBe("bigint");
  });

  test("GET_CREDITS via SDK", async () => {
    if (!env.chainRunning) return;
    const credits = await service.sdk.payments.getCredits();
    expect(typeof credits).toBe("bigint");
  });

  test("LIST_PAYMASTERS via SDK", async () => {
    if (!env.chainRunning) return;
    const paymasters = await service.sdk.payments.listPaymasters();
    expect(Array.isArray(paymasters)).toBe(true);
  });

  test("GET_PAYMASTER_STATUS via SDK", async () => {
    if (!env.chainRunning) return;
    const status = await service.sdk.payments.getPaymasterStatus();
    expect(status).toBeDefined();
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          A2A ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("A2A Actions", () => {
  test("DISCOVER_AGENTS via SDK", async () => {
    if (!env.servicesRunning) return;
    const agents = await service.sdk.a2a.discoverAgents();
    expect(Array.isArray(agents)).toBe(true);
  });

  test("DISCOVER gateway via SDK", async () => {
    if (!env.servicesRunning) return;
    const card = await service.sdk.a2a.discover("http://localhost:4000");
    expect(card).toBeDefined();
    expect(card.name).toBeDefined();
  });

  test("CALL gateway skill via SDK", async () => {
    if (!env.servicesRunning) return;
    const result = await service.sdk.a2a.call("http://localhost:4000", {
      skill: "list-protocol-tokens",
      params: {},
    });
    expect(result).toBeDefined();
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          GAMES ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Games Actions", () => {
  test("GET_GOLD_BALANCE via SDK", async () => {
    if (!env.chainRunning) return;
    const balance = await service.sdk.games.getGoldBalance(service.sdk.address);
    expect(typeof balance).toBe("bigint");
  });

  test("GET_ITEM_BALANCE via SDK", async () => {
    if (!env.chainRunning) return;
    const balance = await service.sdk.games.getItemBalance(service.sdk.address, 1n);
    expect(typeof balance).toBe("bigint");
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          CONTAINERS ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Containers Actions", () => {
  test("LIST_MY_REPOS via SDK", async () => {
    if (!env.chainRunning) return;
    const repos = await service.sdk.containers.listMyRepositories();
    expect(Array.isArray(repos)).toBe(true);
  });

  test("GET_REPO_ID via SDK", () => {
    const repoId = service.sdk.containers.getRepoId(service.sdk.address, "test");
    expect(repoId).toMatch(/^0x[a-fA-F0-9]{64}$/);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          LAUNCHPAD ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Launchpad Actions", () => {
  test("LIST_PRESALES via SDK", async () => {
    if (!env.chainRunning) return;
    const presales = await service.sdk.launchpad.listActivePresales();
    expect(Array.isArray(presales)).toBe(true);
  });

  test("LIST_BONDING_CURVES via SDK", async () => {
    if (!env.chainRunning) return;
    const curves = await service.sdk.launchpad.listActiveCurves();
    expect(Array.isArray(curves)).toBe(true);
  });

  test("LIST_MY_LP_LOCKS via SDK", async () => {
    if (!env.chainRunning) return;
    const locks = await service.sdk.launchpad.listMyLPLocks();
    expect(Array.isArray(locks)).toBe(true);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          MODERATION ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Moderation Actions", () => {
  test("LIST_CASES via SDK", async () => {
    if (!env.chainRunning) return;
    const cases = await service.sdk.moderation.listCases();
    expect(Array.isArray(cases)).toBe(true);
  });

  test("LIST_MY_CASES via SDK", async () => {
    if (!env.chainRunning) return;
    const cases = await service.sdk.moderation.listMyCases();
    expect(Array.isArray(cases)).toBe(true);
  });

  test("LIST_MY_EVIDENCE via SDK", async () => {
    if (!env.chainRunning) return;
    const evidence = await service.sdk.moderation.listMyEvidence();
    expect(Array.isArray(evidence)).toBe(true);
  });

  test("GET_UNCLAIMED_REWARDS via SDK", async () => {
    if (!env.chainRunning) return;
    const rewards = await service.sdk.moderation.getUnclaimedRewards();
    expect(typeof rewards).toBe("bigint");
  });

  test("IS_TRUSTED via SDK", async () => {
    if (!env.chainRunning) return;
    const trusted = await service.sdk.moderation.isTrusted(service.sdk.address);
    expect(typeof trusted).toBe("boolean");
  });

  test("IS_SUSPICIOUS via SDK", async () => {
    if (!env.chainRunning) return;
    const suspicious = await service.sdk.moderation.isSuspicious(service.sdk.address);
    expect(typeof suspicious).toBe("boolean");
  });

  test("GET_AGGREGATE_SCORE via SDK", async () => {
    if (!env.chainRunning) return;
    const score = await service.sdk.moderation.getAggregateScore(service.sdk.address);
    expect(typeof score).toBe("number");
  });

  test("GET_LABELS via SDK", async () => {
    if (!env.chainRunning) return;
    const labels = await service.sdk.moderation.getLabels(service.sdk.address);
    expect(Array.isArray(labels)).toBe(true);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          WORK ACTIONS
// ═══════════════════════════════════════════════════════════════════════════

describe("Work Actions", () => {
  test("LIST_BOUNTIES via SDK", async () => {
    if (!env.chainRunning) return;
    const bounties = await service.sdk.work.listBounties();
    expect(Array.isArray(bounties)).toBe(true);
  });

  test("LIST_MY_BOUNTIES via SDK", async () => {
    if (!env.chainRunning) return;
    const bounties = await service.sdk.work.listMyBounties();
    expect(Array.isArray(bounties)).toBe(true);
  });

  test("LIST_MY_HUNTS via SDK", async () => {
    if (!env.chainRunning) return;
    const hunts = await service.sdk.work.listMyHunts();
    expect(Array.isArray(hunts)).toBe(true);
  });

  test("LIST_PROJECTS via SDK", async () => {
    if (!env.chainRunning) return;
    const projects = await service.sdk.work.listProjects();
    expect(Array.isArray(projects)).toBe(true);
  });

  test("LIST_MY_PROJECTS via SDK", async () => {
    if (!env.chainRunning) return;
    const projects = await service.sdk.work.listMyProjects();
    expect(Array.isArray(projects)).toBe(true);
  });

  test("LIST_GUARDIANS via SDK", async () => {
    if (!env.chainRunning) return;
    const guardians = await service.sdk.work.listGuardians();
    expect(Array.isArray(guardians)).toBe(true);
  });

  test("GET_GUARDIAN via SDK", async () => {
    if (!env.chainRunning) return;
    const guardian = await service.sdk.work.getGuardian(service.sdk.address);
    expect(guardian === null || typeof guardian === "object").toBe(true);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                    ON-CHAIN WRITE OPERATIONS (DEVNET)
// ═══════════════════════════════════════════════════════════════════════════

describe("On-Chain Write Actions", () => {
  test.skip("CREATE_BOUNTY and CLAIM_BOUNTY workflow", async () => {
    if (!env.contractsDeployed) return;

    // Create bounty
    const createResult = await service.sdk.work.createBounty({
      title: "E2E Action Test Bounty " + Date.now(),
      description: "Test bounty for e2e action testing",
      reward: parseEther("0.1"),
      deadline: Math.floor(Date.now() / 1000) + 86400,
      tags: ["test"],
    });

    expect(createResult.bountyId).toBeDefined();
    expect(createResult.txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);

    // Verify bounty exists
    const bounty = await service.sdk.work.getBounty(createResult.bountyId);
    expect(bounty).not.toBeNull();
    expect(bounty?.title).toContain("E2E Action Test Bounty");
  });

  test.skip("CREATE_MODERATION_CASE workflow", async () => {
    if (!env.contractsDeployed) return;

    const user2Address = "0x70997970C51812dc3A010C7d01b50e0d17dc79C8" as Address;

    const createResult = await service.sdk.moderation.createCase({
      reportedEntity: user2Address,
      reportType: "spam",
      description: "E2E test case for action testing",
      stake: parseEther("0.01"),
    });

    expect(createResult.caseId).toBeDefined();
    expect(createResult.txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);

    // Verify case exists
    const caseData = await service.sdk.moderation.getCase(createResult.caseId);
    expect(caseData).not.toBeNull();
  });

  test.skip("CREATE_PROJECT workflow", async () => {
    if (!env.contractsDeployed) return;

    const createResult = await service.sdk.work.createProject({
      name: "E2E Action Test Project " + Date.now(),
      description: "Test project for e2e action testing",
      repository: "https://github.com/test/action-repo",
      budget: parseEther("0.5"),
    });

    expect(createResult.projectId).toBeDefined();
    expect(createResult.txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);

    // Verify project exists
    const project = await service.sdk.work.getProject(createResult.projectId);
    expect(project).not.toBeNull();
  });

  test.skip("REGISTER_AGENT workflow", async () => {
    if (!env.contractsDeployed) return;

    const result = await service.sdk.identity.register({
      name: "E2E Test Agent " + Date.now(),
      tags: ["test", "e2e", "action"],
      a2aEndpoint: "https://test.example.com/a2a",
    });

    expect(result.agentId).toBeDefined();
    expect(result.txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);

    // Verify agent registered
    const agent = await service.sdk.identity.getMyAgent();
    expect(agent).not.toBeNull();
    expect(agent?.tags).toContain("e2e");
  });

  test.skip("REGISTER_NAME workflow", async () => {
    if (!env.contractsDeployed) return;

    const name = "e2eactiontest" + Date.now();
    const result = await service.sdk.names.register(name, 1);

    expect(result.txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);

    // Verify name registered
    const resolved = await service.sdk.names.resolve(name + ".jeju");
    expect(resolved).toBe(service.sdk.address);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                          ACTION COUNT VERIFICATION
// ═══════════════════════════════════════════════════════════════════════════

describe("Action Coverage", () => {
  const actionCategories = {
    compute: [
      "RENT_GPU",
      "RUN_INFERENCE",
      "CREATE_TRIGGER",
      "LIST_PROVIDERS",
      "LIST_MODELS",
      "LIST_MY_RENTALS",
      "GET_SSH_ACCESS",
    ],
    storage: [
      "UPLOAD_FILE",
      "RETRIEVE_FILE",
      "PIN_CID",
      "LIST_PINS",
      "UNPIN",
      "GET_STORAGE_STATS",
      "ESTIMATE_STORAGE_COST",
    ],
    defi: [
      "SWAP_TOKENS",
      "ADD_LIQUIDITY",
      "LIST_POOLS",
      "GET_POOL_STATS",
      "MY_POSITIONS",
    ],
    governance: ["CREATE_PROPOSAL", "VOTE_PROPOSAL"],
    names: ["REGISTER_NAME", "RESOLVE_NAME"],
    identity: ["REGISTER_AGENT"],
    crosschain: [
      "CROSS_CHAIN_TRANSFER",
      "CREATE_INTENT",
      "TRACK_INTENT",
      "LIST_SOLVERS",
      "LIST_ROUTES",
    ],
    payments: ["CHECK_BALANCE"],
    bazaar: ["LAUNCH_TOKEN", "LIST_NFTS", "LIST_NAMES_FOR_SALE"],
    moderation: [
      "REPORT_AGENT",
      "LIST_MODERATION_CASES",
      "SUBMIT_EVIDENCE",
      "SUPPORT_EVIDENCE",
      "GET_EVIDENCE",
      "LIST_CASE_EVIDENCE",
      "CLAIM_EVIDENCE_REWARD",
      "CREATE_MODERATION_CASE",
      "GET_MODERATION_CASE",
      "APPEAL_CASE",
      "ISSUE_REPUTATION_LABEL",
      "GET_REPUTATION_LABELS",
      "CHECK_TRUST_STATUS",
    ],
    nodes: ["LIST_NODES", "GET_NODE_STATS"],
    a2a: ["CALL_AGENT", "DISCOVER_AGENTS"],
    games: [
      "GET_PLAYER_INFO",
      "GET_GOLD_BALANCE",
      "TRANSFER_GOLD",
      "GET_ITEM_BALANCE",
      "TRANSFER_ITEM",
      "LINK_GAME_AGENT",
      "GET_GAME_STATS",
    ],
    containers: [
      "CREATE_CONTAINER_REPO",
      "GET_CONTAINER_REPO",
      "LIST_MY_REPOS",
      "GET_IMAGE_MANIFEST",
      "STAR_CONTAINER_REPO",
      "GRANT_REPO_ACCESS",
    ],
    launchpad: [
      "CREATE_TOKEN",
      "CREATE_PRESALE",
      "CONTRIBUTE_PRESALE",
      "LIST_PRESALES",
      "CREATE_BONDING_CURVE",
      "BUY_FROM_CURVE",
      "SELL_TO_CURVE",
      "LIST_BONDING_CURVES",
      "LOCK_LP",
    ],
    work: [
      "CREATE_BOUNTY",
      "LIST_BOUNTIES",
      "CLAIM_BOUNTY",
      "SUBMIT_BOUNTY_WORK",
      "APPROVE_SUBMISSION",
      "REJECT_SUBMISSION",
      "CREATE_PROJECT",
      "LIST_PROJECTS",
      "CREATE_PROJECT_TASK",
      "GET_PROJECT_TASKS",
      "REGISTER_GUARDIAN",
      "LIST_GUARDIANS",
    ],
  };

  test("plugin has all expected action categories", () => {
    const actionNames = jejuPlugin.actions!.map((a) => a.name);

    for (const [category, expectedActions] of Object.entries(actionCategories)) {
      for (const action of expectedActions) {
        const found = actionNames.some(
          (name) => name === action || name.includes(action.replace(/_/g, "")),
        );
        if (!found) {
          console.warn(`Missing action: ${action} in category ${category}`);
        }
      }
    }
  });

  test("plugin has minimum action count", () => {
    const totalExpected = Object.values(actionCategories).flat().length;
    expect(jejuPlugin.actions!.length).toBeGreaterThanOrEqual(totalExpected - 10); // Allow some variance
  });
});
