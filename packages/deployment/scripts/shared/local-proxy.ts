/**
 * Local Development Proxy
 *
 * Manages a Caddy reverse proxy for local development
 * Routes *.local.jejunetwork.org to localhost ports
 *
 * Automatically configures:
 * - Hosts file entries (with sudo prompt if needed)
 * - Caddy reverse proxy for clean URLs without ports
 *
 * Available services:
 * - gateway.local.jejunetwork.org -> localhost:4001
 * - bazaar.local.jejunetwork.org -> localhost:4006
 * - docs.local.jejunetwork.org -> localhost:4004
 * - rpc.local.jejunetwork.org -> localhost:6546
 */

import {
  existsSync,
  mkdirSync,
  readFileSync,
  unlinkSync,
  writeFileSync,
} from 'node:fs'
import { $ } from 'bun'

const DOMAIN = 'local.jejunetwork.org'
const CADDY_DIR = '.jeju/caddy'
const CADDYFILE_PATH = `${CADDY_DIR}/Caddyfile`
const PID_FILE = `${CADDY_DIR}/caddy.pid`

// Hosts file block markers
const HOSTS_BLOCK_START = '# JEJU LOCAL DEV START'
const HOSTS_BLOCK_END = '# JEJU LOCAL DEV END'

// Service port mappings
const SERVICES: Record<string, number> = {
  gateway: 4001,
  bazaar: 4006,
  docs: 4004,
  indexer: 4350,
  rpc: 9545,
  ws: 6547,
  crucible: 4003,
  compute: 4007,
  storage: 4010,
  monitoring: 4002,
  autocrat: 4008,
  factory: 4009,
  wallet: 4011,
  dws: 4012,
}

interface ProxyConfig {
  services?: Partial<typeof SERVICES>
  domain?: string
}

// ============================================================================
// Hosts File Management
// ============================================================================

function getHostsFilePath(): string {
  if (process.platform === 'win32') {
    return 'C:\\Windows\\System32\\drivers\\etc\\hosts'
  }
  return '/etc/hosts'
}

function generateHostsBlock(config: ProxyConfig = {}): string {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }

  const lines: string[] = [
    HOSTS_BLOCK_START,
    '# Auto-generated by Jeju - do not edit manually',
    `# Domain: ${domain}`,
    '',
  ]

  // Add root domain
  lines.push(`127.0.0.1  ${domain}`)

  // Add each service subdomain
  for (const service of Object.keys(services)) {
    lines.push(`127.0.0.1  ${service}.${domain}`)
  }

  lines.push('')
  lines.push(HOSTS_BLOCK_END)

  return lines.join('\n')
}

function readHostsFile(): string {
  const hostsPath = getHostsFilePath()
  if (!existsSync(hostsPath)) {
    return ''
  }
  return readFileSync(hostsPath, 'utf-8')
}

export function hasJejuHostsBlock(): boolean {
  const content = readHostsFile()
  return (
    content.includes(HOSTS_BLOCK_START) && content.includes(HOSTS_BLOCK_END)
  )
}

export function getHostsBlockStatus(): {
  exists: boolean
  current: string
  expected: string
} {
  const content = readHostsFile()
  const expected = generateHostsBlock()

  if (!content.includes(HOSTS_BLOCK_START)) {
    return { exists: false, current: '', expected }
  }

  const startIdx = content.indexOf(HOSTS_BLOCK_START)
  const endIdx = content.indexOf(HOSTS_BLOCK_END)

  if (endIdx === -1) {
    return { exists: false, current: '', expected }
  }

  const current = content.substring(startIdx, endIdx + HOSTS_BLOCK_END.length)
  return { exists: true, current, expected }
}

export async function ensureHostsFile(
  config: ProxyConfig = {},
): Promise<boolean> {
  const hostsPath = getHostsFilePath()

  // Check hosts file status (no sudo needed - just reading)
  const status = getHostsBlockStatus()
  const expectedBlock = generateHostsBlock(config)

  // Check if block already exists and is up to date
  if (status.exists && status.current.trim() === expectedBlock.trim()) {
    console.log('   ‚úÖ Hosts file already configured')
    return true
  }

  // Need to update - explain what will happen
  if (status.exists) {
    console.log('   üîÑ Hosts file needs update')
  } else {
    console.log('   üìù Jeju entries not found in hosts file')
  }

  // Read current content
  let content = readHostsFile()

  // Remove existing block if present
  if (status.exists) {
    const startIdx = content.indexOf(HOSTS_BLOCK_START)
    const endIdx = content.indexOf(HOSTS_BLOCK_END) + HOSTS_BLOCK_END.length
    content = content.substring(0, startIdx) + content.substring(endIdx)
  }

  // Add new block at end
  content = `${content.trimEnd()}\n\n${expectedBlock}\n`

  // Write to temp file first
  const tempFile = '/tmp/jeju-hosts-update'
  writeFileSync(tempFile, content)

  // Determine if we need sudo
  const platform = process.platform

  if (platform === 'win32') {
    // Windows - need admin privileges
    console.log('   ‚ö†Ô∏è  Windows detected - need Administrator privileges')
    console.log(`   Run this command in an Administrator PowerShell:`)
    console.log(`   Copy-Item "${tempFile}" -Destination "${hostsPath}"`)
    console.log('')
    console.log('   Or manually add these lines to your hosts file:')
    console.log(expectedBlock)
    return false
  }

  // macOS / Linux - use sudo to write
  console.log('   üîê Requesting sudo access to write hosts file...')

  const result = await $`sudo cp ${tempFile} ${hostsPath}`.nothrow()

  if (result.exitCode !== 0) {
    console.error('   ‚ùå Failed to update hosts file')
    console.log('')
    console.log(`   To fix manually, add these lines to ${hostsPath}:`)
    console.log(expectedBlock)
    return false
  }

  // Clean up temp file
  await $`rm ${tempFile}`.nothrow().quiet()

  console.log('   ‚úÖ Hosts file updated')
  return true
}

export async function removeHostsBlock(): Promise<boolean> {
  const status = getHostsBlockStatus()

  if (!status.exists) {
    console.log('   ‚ÑπÔ∏è  No Jeju block in hosts file')
    return true
  }

  const hostsPath = getHostsFilePath()
  let content = readHostsFile()

  // Remove existing block
  const startIdx = content.indexOf(HOSTS_BLOCK_START)
  const endIdx = content.indexOf(HOSTS_BLOCK_END) + HOSTS_BLOCK_END.length
  content = content.substring(0, startIdx) + content.substring(endIdx)

  // Clean up extra newlines
  content = `${content.replace(/\n{3,}/g, '\n\n').trim()}\n`

  // Write to temp file
  const tempFile = '/tmp/jeju-hosts-remove'
  writeFileSync(tempFile, content)

  if (process.platform === 'win32') {
    console.log('   ‚ö†Ô∏è  Run in Administrator PowerShell:')
    console.log(`   Copy-Item "${tempFile}" -Destination "${hostsPath}"`)
    return false
  }

  console.log('   üîê Requesting sudo access to update hosts file...')
  const result = await $`sudo cp ${tempFile} ${hostsPath}`.nothrow()

  await $`rm ${tempFile}`.nothrow().quiet()

  if (result.exitCode !== 0) {
    console.error('   ‚ùå Failed to remove hosts block')
    return false
  }

  console.log('   ‚úÖ Hosts block removed')
  return true
}

// ============================================================================
// Caddy Proxy Management
// ============================================================================

export async function isCaddyInstalled(): Promise<boolean> {
  const result = await $`which caddy`.nothrow().quiet()
  return result.exitCode === 0
}

export async function installCaddy(): Promise<boolean> {
  const platform = process.platform

  console.log('üì¶ Installing Caddy...')

  if (platform === 'darwin') {
    // macOS
    const result = await $`brew install caddy`.nothrow()
    return result.exitCode === 0
  } else if (platform === 'linux') {
    // Linux - try apt first, then other package managers
    let result = await $`which apt-get`.nothrow().quiet()
    if (result.exitCode === 0) {
      await $`sudo apt-get update`.nothrow().quiet()
      result = await $`sudo apt-get install -y caddy`.nothrow()
      return result.exitCode === 0
    }

    // Try yum/dnf
    result = await $`which dnf`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`sudo dnf install -y caddy`.nothrow()
      return result.exitCode === 0
    }

    // Fallback: download binary
    console.log('   Downloading Caddy binary...')
    const arch = process.arch === 'x64' ? 'amd64' : 'arm64'
    const url = `https://caddyserver.com/api/download?os=linux&arch=${arch}`
    result =
      await $`curl -fsSL ${url} -o /tmp/caddy && chmod +x /tmp/caddy && sudo mv /tmp/caddy /usr/local/bin/caddy`.nothrow()
    return result.exitCode === 0
  } else if (platform === 'win32') {
    // Windows - use scoop or chocolatey
    let result = await $`where scoop`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`scoop install caddy`.nothrow()
      return result.exitCode === 0
    }

    result = await $`where choco`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`choco install caddy -y`.nothrow()
      return result.exitCode === 0
    }

    console.error(
      '   Please install Caddy manually: https://caddyserver.com/docs/install#windows',
    )
    return false
  }

  return false
}

export function generateCaddyfile(config: ProxyConfig = {}): string {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }
  // Use port 8080 to avoid needing root privileges (port 80 requires sudo)
  const proxyPort = 8080

  const entries: string[] = [
    '# Auto-generated Caddyfile for local development',
    '# Do not edit - regenerated on each `bun run dev`',
    '',
    '# Global options',
    '{',
    '    # Disable HTTPS for local development',
    '    auto_https off',
    '    # Bind to localhost only',
    '    default_bind 127.0.0.1',
    '}',
    '',
  ]

  // Root landing page
  entries.push(`# Landing page at local.${domain.replace('local.', '')}`)
  entries.push(`:${proxyPort} {`)
  entries.push(
    `    respond "Jeju Local Development\\n\\nAvailable services:\\n${Object.keys(
      services,
    )
      .map((s) => `- http://${s}.${domain}:${proxyPort}`)
      .join('\\n')}" 200`,
  )
  entries.push(`}`)
  entries.push('')

  // Service routes
  for (const [service, port] of Object.entries(services)) {
    entries.push(`# ${service}`)
    entries.push(`${service}.${domain}:${proxyPort} {`)
    entries.push(`    reverse_proxy localhost:${port}`)
    entries.push(`}`)
    entries.push('')
  }

  return entries.join('\n')
}

export async function startProxy(config: ProxyConfig = {}): Promise<boolean> {
  const domain = config.domain || DOMAIN

  console.log(`üåê Setting up local proxy for ${domain}...\n`)

  // Step 1: Check hosts file (reading doesn't need sudo)
  console.log('1. Checking hosts file...')
  const hostsOk = await ensureHostsFile(config)
  if (!hostsOk) {
    console.log('   ‚ö†Ô∏è  Hosts file not configured - URLs will not resolve')
    console.log('   You can still access services at localhost:PORT\n')
  }
  console.log('')

  // Step 2: Check if Caddy is installed
  console.log('2. Checking Caddy installation...')
  if (!(await isCaddyInstalled())) {
    console.log('   ‚ö†Ô∏è  Caddy not installed')
    const installed = await installCaddy()
    if (!installed) {
      console.error('   ‚ùå Failed to install Caddy')
      console.error(
        '   Local proxy disabled - apps available at localhost ports',
      )
      return false
    }
    console.log('   ‚úÖ Caddy installed')
  } else {
    console.log('   ‚úÖ Caddy available')
  }
  console.log('')

  // Step 3: Create config directory
  if (!existsSync(CADDY_DIR)) {
    mkdirSync(CADDY_DIR, { recursive: true })
  }

  // Step 4: Generate Caddyfile
  console.log('3. Generating Caddy configuration...')
  const caddyfile = generateCaddyfile(config)
  writeFileSync(CADDYFILE_PATH, caddyfile)
  console.log('   ‚úÖ Caddyfile written')
  console.log('')

  // Step 5: Stop any existing Caddy process
  await stopProxy()

  // Step 6: Start Caddy
  console.log('4. Starting reverse proxy...')

  const proc = Bun.spawn(['caddy', 'run', '--config', CADDYFILE_PATH], {
    cwd: process.cwd(),
    stdout: 'pipe',
    stderr: 'pipe',
  })

  // Save PID
  writeFileSync(PID_FILE, String(proc.pid))

  // Wait for startup
  await Bun.sleep(500)

  // Check if running
  if (proc.exitCode !== null) {
    const stderr = await new Response(proc.stderr).text()
    console.error('   ‚ùå Proxy failed to start:', stderr)
    return false
  }

  console.log('   ‚úÖ Caddy running')
  console.log('')

  // Print available URLs
  console.log('üéâ Local proxy ready. Available URLs:')
  const urls = getLocalUrls(config)
  for (const [name, url] of Object.entries(urls)) {
    console.log(`   ${name.padEnd(12)} ${url}`)
  }
  console.log('')

  return true
}

export async function stopProxy(): Promise<void> {
  if (existsSync(PID_FILE)) {
    const pid = parseInt(await Bun.file(PID_FILE).text(), 10)
    if (pid) {
      await $`kill ${pid}`.nothrow().quiet()
    }
    unlinkSync(PID_FILE)
  }

  // Also try to stop any caddy processes using our config
  await $`pkill -f "caddy run --config ${CADDYFILE_PATH}"`.nothrow().quiet()
}

export function getLocalUrls(config: ProxyConfig = {}): Record<string, string> {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }
  const proxyPort = 8080

  const urls: Record<string, string> = {}
  for (const service of Object.keys(services)) {
    urls[service] = `http://${service}.${domain}:${proxyPort}`
  }
  return urls
}

// CLI entry point
if (import.meta.main) {
  const command = process.argv[2]

  switch (command) {
    case 'start':
      await startProxy()
      break

    case 'stop':
      await stopProxy()
      console.log('‚úÖ Proxy stopped')
      break

    case 'urls':
      console.log('Local development URLs:')
      for (const [name, url] of Object.entries(getLocalUrls())) {
        console.log(`  ${name.padEnd(12)} ${url}`)
      }
      break

    case 'caddyfile':
      console.log(generateCaddyfile())
      break

    case 'hosts':
    case 'hosts:check': {
      const status = getHostsBlockStatus()
      if (status.exists) {
        console.log('‚úÖ Jeju hosts block found:\n')
        console.log(status.current)
      } else {
        console.log('‚ùå Jeju hosts block not found')
        console.log('\nExpected block:\n')
        console.log(status.expected)
        console.log(
          '\nRun: bun run packages/deployment/scripts/shared/local-proxy.ts hosts:add',
        )
      }
      break
    }

    case 'hosts:add':
      console.log('üìù Adding Jeju block to hosts file...\n')
      await ensureHostsFile()
      break

    case 'hosts:remove':
      console.log('üóëÔ∏è  Removing Jeju block from hosts file...\n')
      await removeHostsBlock()
      break

    case 'hosts:show':
      console.log(generateHostsBlock())
      break

    case 'setup':
      // Full setup - hosts + proxy
      await startProxy()
      break

    default:
      console.log(`
Jeju Local Proxy Manager

Usage: bun run packages/deployment/scripts/shared/local-proxy.ts <command>

Commands:
  start         Start the reverse proxy (with hosts check)
  stop          Stop the reverse proxy
  setup         Full setup (hosts + proxy)
  urls          Show available local URLs
  caddyfile     Print generated Caddyfile

Hosts Management:
  hosts         Check if Jeju block exists in hosts file
  hosts:add     Add Jeju block to hosts file (requires sudo)
  hosts:remove  Remove Jeju block from hosts file (requires sudo)
  hosts:show    Print the hosts block that would be added

Domain: ${DOMAIN}
Services: ${Object.keys(SERVICES).join(', ')}
`)
  }
}
