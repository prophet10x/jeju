/**
 * Local Development Proxy
 *
 * Manages a Caddy reverse proxy for local development
 * Routes *.local.jejunetwork.org to localhost ports
 *
 * Automatically configures:
 * - Hosts file entries (with sudo prompt if needed)
 * - Caddy reverse proxy for clean URLs without ports
 *
 * Port mappings are loaded from @jejunetwork/config
 */

import {
  existsSync,
  mkdirSync,
  readFileSync,
  unlinkSync,
  writeFileSync,
} from 'node:fs'
import { CORE_PORTS, INFRA_PORTS } from '@jejunetwork/config'
import { $ } from 'bun'

const DOMAIN = 'local.jejunetwork.org'
const CADDY_DIR = '.jeju/caddy'
const CADDYFILE_PATH = `${CADDY_DIR}/Caddyfile`
const PID_FILE = `${CADDY_DIR}/caddy.pid`

// Hosts file block markers
const HOSTS_BLOCK_START = '# JEJU LOCAL DEV START'
const HOSTS_BLOCK_END = '# JEJU LOCAL DEV END'

// Service port mappings (from centralized config)
const SERVICES: Record<string, number> = {
  gateway: CORE_PORTS.GATEWAY.get(),
  bazaar: CORE_PORTS.BAZAAR.get(),
  docs: CORE_PORTS.DOCUMENTATION.get(),
  indexer: CORE_PORTS.INDEXER_GRAPHQL.get(),
  rpc: INFRA_PORTS.L2_RPC.get(),
  ws: INFRA_PORTS.L2_WS.get(),
  crucible: CORE_PORTS.CRUCIBLE_API.get(),
  compute: CORE_PORTS.COMPUTE.get(),
  ipfs: CORE_PORTS.IPFS.get(),
  monitoring: CORE_PORTS.NODE_EXPLORER_API.get(),
  autocrat: CORE_PORTS.AUTOCRAT_API.get(),
  factory: CORE_PORTS.FACTORY.get(),
  oif: CORE_PORTS.OIF_AGGREGATOR.get(),
  dws: CORE_PORTS.DWS_API.get(),
}

interface ProxyConfig {
  services?: Partial<typeof SERVICES>
  domain?: string
}

// Hosts File Management

function getHostsFilePath(): string {
  if (process.platform === 'win32') {
    return 'C:\\Windows\\System32\\drivers\\etc\\hosts'
  }
  return '/etc/hosts'
}

function generateHostsBlock(config: ProxyConfig = {}): string {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }

  const lines: string[] = [
    HOSTS_BLOCK_START,
    '# Auto-generated by Jeju - do not edit manually',
    `# Domain: ${domain}`,
    '',
  ]

  // Add root domain
  lines.push(`127.0.0.1  ${domain}`)

  // Add each service subdomain
  for (const service of Object.keys(services)) {
    lines.push(`127.0.0.1  ${service}.${domain}`)
  }

  lines.push('')
  lines.push(HOSTS_BLOCK_END)

  return lines.join('\n')
}

function readHostsFile(): string {
  const hostsPath = getHostsFilePath()
  if (!existsSync(hostsPath)) {
    return ''
  }
  return readFileSync(hostsPath, 'utf-8')
}

export function hasJejuHostsBlock(): boolean {
  const content = readHostsFile()
  return (
    content.includes(HOSTS_BLOCK_START) && content.includes(HOSTS_BLOCK_END)
  )
}

export function getHostsBlockStatus(): {
  exists: boolean
  current: string
  expected: string
} {
  const content = readHostsFile()
  const expected = generateHostsBlock()

  if (!content.includes(HOSTS_BLOCK_START)) {
    return { exists: false, current: '', expected }
  }

  const startIdx = content.indexOf(HOSTS_BLOCK_START)
  const endIdx = content.indexOf(HOSTS_BLOCK_END)

  if (endIdx === -1) {
    return { exists: false, current: '', expected }
  }

  const current = content.substring(startIdx, endIdx + HOSTS_BLOCK_END.length)
  return { exists: true, current, expected }
}

export async function ensureHostsFile(
  config: ProxyConfig = {},
): Promise<boolean> {
  const hostsPath = getHostsFilePath()

  // Check hosts file status (no sudo needed - just reading)
  const status = getHostsBlockStatus()
  const expectedBlock = generateHostsBlock(config)

  // Check if block already exists and is up to date
  if (status.exists && status.current.trim() === expectedBlock.trim()) {
    console.log('   ‚úÖ Hosts file already configured')
    return true
  }

  // Need to update - explain what will happen
  if (status.exists) {
    console.log('   üîÑ Hosts file needs update')
  } else {
    console.log('   üìù Jeju entries not found in hosts file')
  }

  // Read current content
  let content = readHostsFile()

  // Remove existing block if present
  if (status.exists) {
    const startIdx = content.indexOf(HOSTS_BLOCK_START)
    const endIdx = content.indexOf(HOSTS_BLOCK_END) + HOSTS_BLOCK_END.length
    content = content.substring(0, startIdx) + content.substring(endIdx)
  }

  // Add new block at end
  content = `${content.trimEnd()}\n\n${expectedBlock}\n`

  // Write to temp file first
  const tempFile = '/tmp/jeju-hosts-update'
  writeFileSync(tempFile, content)

  // Determine if we need sudo
  const platform = process.platform

  if (platform === 'win32') {
    // Windows - need admin privileges
    console.log('   ‚ö†Ô∏è  Windows detected - need Administrator privileges')
    console.log(`   Run this command in an Administrator PowerShell:`)
    console.log(`   Copy-Item "${tempFile}" -Destination "${hostsPath}"`)
    console.log('')
    console.log('   Or manually add these lines to your hosts file:')
    console.log(expectedBlock)
    return false
  }

  // macOS / Linux - use sudo to write
  console.log('   üîê Requesting sudo access to write hosts file...')

  const result = await $`sudo cp ${tempFile} ${hostsPath}`.nothrow()

  if (result.exitCode !== 0) {
    console.error('   ‚ùå Failed to update hosts file')
    console.log('')
    console.log(`   To fix manually, add these lines to ${hostsPath}:`)
    console.log(expectedBlock)
    return false
  }

  // Clean up temp file
  await $`rm ${tempFile}`.nothrow().quiet()

  console.log('   ‚úÖ Hosts file updated')
  return true
}

export async function removeHostsBlock(): Promise<boolean> {
  const status = getHostsBlockStatus()

  if (!status.exists) {
    console.log('   ‚ÑπÔ∏è  No Jeju block in hosts file')
    return true
  }

  const hostsPath = getHostsFilePath()
  let content = readHostsFile()

  // Remove existing block
  const startIdx = content.indexOf(HOSTS_BLOCK_START)
  const endIdx = content.indexOf(HOSTS_BLOCK_END) + HOSTS_BLOCK_END.length
  content = content.substring(0, startIdx) + content.substring(endIdx)

  // Clean up extra newlines
  content = `${content.replace(/\n{3,}/g, '\n\n').trim()}\n`

  // Write to temp file
  const tempFile = '/tmp/jeju-hosts-remove'
  writeFileSync(tempFile, content)

  if (process.platform === 'win32') {
    console.log('   ‚ö†Ô∏è  Run in Administrator PowerShell:')
    console.log(`   Copy-Item "${tempFile}" -Destination "${hostsPath}"`)
    return false
  }

  console.log('   üîê Requesting sudo access to update hosts file...')
  const result = await $`sudo cp ${tempFile} ${hostsPath}`.nothrow()

  await $`rm ${tempFile}`.nothrow().quiet()

  if (result.exitCode !== 0) {
    console.error('   ‚ùå Failed to remove hosts block')
    return false
  }

  console.log('   ‚úÖ Hosts block removed')
  return true
}

// Caddy Proxy Management

export async function isCaddyInstalled(): Promise<boolean> {
  const result = await $`which caddy`.nothrow().quiet()
  return result.exitCode === 0
}

export async function installCaddy(): Promise<boolean> {
  const platform = process.platform

  console.log('üì¶ Installing Caddy...')

  if (platform === 'darwin') {
    // macOS
    const result = await $`brew install caddy`.nothrow()
    return result.exitCode === 0
  } else if (platform === 'linux') {
    // Linux - try apt first, then other package managers
    let result = await $`which apt-get`.nothrow().quiet()
    if (result.exitCode === 0) {
      await $`sudo apt-get update`.nothrow().quiet()
      result = await $`sudo apt-get install -y caddy`.nothrow()
      return result.exitCode === 0
    }

    // Try yum/dnf
    result = await $`which dnf`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`sudo dnf install -y caddy`.nothrow()
      return result.exitCode === 0
    }

    // Fallback: download binary
    console.log('   Downloading Caddy binary...')
    const arch = process.arch === 'x64' ? 'amd64' : 'arm64'
    const url = `https://caddyserver.com/api/download?os=linux&arch=${arch}`
    result =
      await $`curl -fsSL ${url} -o /tmp/caddy && chmod +x /tmp/caddy && sudo mv /tmp/caddy /usr/local/bin/caddy`.nothrow()
    return result.exitCode === 0
  } else if (platform === 'win32') {
    // Windows - use scoop or chocolatey
    let result = await $`where scoop`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`scoop install caddy`.nothrow()
      return result.exitCode === 0
    }

    result = await $`where choco`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`choco install caddy -y`.nothrow()
      return result.exitCode === 0
    }

    console.error(
      '   Please install Caddy manually: https://caddyserver.com/docs/install#windows',
    )
    return false
  }

  return false
}

export function generateCaddyfile(config: ProxyConfig = {}): string {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }
  // Use port 8080 to avoid needing root privileges (port 80 requires sudo)
  const proxyPort = 8080

  const entries: string[] = [
    '# Auto-generated Caddyfile for local development',
    '# Do not edit - regenerated on each `bun run dev`',
    '',
    '# Global options',
    '{',
    '    # Disable HTTPS for local development',
    '    auto_https off',
    '    # Bind to localhost only',
    '    default_bind 127.0.0.1',
    '}',
    '',
  ]

  // Root landing page
  entries.push(`# Landing page at local.${domain.replace('local.', '')}`)
  entries.push(`:${proxyPort} {`)
  entries.push(
    `    respond "Jeju Local Development\\n\\nAvailable services:\\n${Object.keys(
      services,
    )
      .map((s) => `- http://${s}.${domain}:${proxyPort}`)
      .join('\\n')}" 200`,
  )
  entries.push(`}`)
  entries.push('')

  // Service routes
  for (const [service, port] of Object.entries(services)) {
    entries.push(`# ${service}`)
    entries.push(`${service}.${domain}:${proxyPort} {`)
    entries.push(`    reverse_proxy localhost:${port}`)
    entries.push(`}`)
    entries.push('')
  }

  return entries.join('\n')
}

export async function startProxy(config: ProxyConfig = {}): Promise<boolean> {
  const domain = config.domain || DOMAIN

  console.log(`üåê Setting up local proxy for ${domain}...\n`)

  // Step 1: Check hosts file (reading doesn't need sudo)
  console.log('1. Checking hosts file...')
  const hostsOk = await ensureHostsFile(config)
  if (!hostsOk) {
    console.log('   ‚ö†Ô∏è  Hosts file not configured - URLs will not resolve')
    console.log('   You can still access services at localhost:PORT\n')
  }
  console.log('')

  // Step 2: Check if Caddy is installed
  console.log('2. Checking Caddy installation...')
  if (!(await isCaddyInstalled())) {
    console.log('   ‚ö†Ô∏è  Caddy not installed')
    const installed = await installCaddy()
    if (!installed) {
      console.error('   ‚ùå Failed to install Caddy')
      console.error(
        '   Local proxy disabled - apps available at localhost ports',
      )
      return false
    }
    console.log('   ‚úÖ Caddy installed')
  } else {
    console.log('   ‚úÖ Caddy available')
  }
  console.log('')

  // Step 3: Create config directory
  if (!existsSync(CADDY_DIR)) {
    mkdirSync(CADDY_DIR, { recursive: true })
  }

  // Step 4: Generate Caddyfile
  console.log('3. Generating Caddy configuration...')
  const caddyfile = generateCaddyfile(config)
  writeFileSync(CADDYFILE_PATH, caddyfile)
  console.log('   ‚úÖ Caddyfile written')
  console.log('')

  // Step 5: Stop any existing Caddy process
  await stopProxy()

  // Step 6: Start Caddy
  console.log('4. Starting reverse proxy...')

  const proc = Bun.spawn(['caddy', 'run', '--config', CADDYFILE_PATH], {
    cwd: process.cwd(),
    stdout: 'pipe',
    stderr: 'pipe',
  })

  // Save PID
  writeFileSync(PID_FILE, String(proc.pid))

  // Wait for startup
  await Bun.sleep(500)

  // Check if running
  if (proc.exitCode !== null) {
    const stderr = await new Response(proc.stderr).text()
    console.error('   ‚ùå Proxy failed to start:', stderr)
    return false
  }

  console.log('   ‚úÖ Caddy running')
  console.log('')

  // Print available URLs
  console.log('üéâ Local proxy ready. Available URLs:')
  const urls = getLocalUrls(config)
  for (const [name, url] of Object.entries(urls)) {
    console.log(`   ${name.padEnd(12)} ${url}`)
  }
  console.log('')

  return true
}

export async function stopProxy(): Promise<void> {
  if (existsSync(PID_FILE)) {
    const pid = parseInt(await Bun.file(PID_FILE).text(), 10)
    if (pid) {
      await $`kill ${pid}`.nothrow().quiet()
    }
    unlinkSync(PID_FILE)
  }

  // Also try to stop any caddy processes using our config
  await $`pkill -f "caddy run --config ${CADDYFILE_PATH}"`.nothrow().quiet()
}

export function getLocalUrls(config: ProxyConfig = {}): Record<string, string> {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }
  const proxyPort = 8080

  const urls: Record<string, string> = {}
  for (const service of Object.keys(services)) {
    urls[service] = `http://${service}.${domain}:${proxyPort}`
  }
  return urls
}

/**
 * Check if port forwarding is already set up
 * Uses file existence checks first to avoid unnecessary sudo prompts
 */
export async function isPortForwardingActive(): Promise<boolean> {
  const platform = process.platform

  if (platform === 'darwin') {
    // First check if our anchor file exists (no sudo needed)
    const anchorPath = '/etc/pf.anchors/jeju'
    if (!existsSync(anchorPath)) {
      return false
    }

    // Check if pf.conf has our anchor configured
    const pfConfResult = await $`cat /etc/pf.conf`.nothrow().quiet()
    if (pfConfResult.exitCode !== 0) {
      return false
    }
    const pfConf = pfConfResult.stdout.toString()
    return pfConf.includes('anchor "jeju"')
  } else if (platform === 'linux') {
    // Check iptables rules file if it exists
    if (existsSync('/etc/iptables/rules.v4')) {
      const rulesResult = await $`cat /etc/iptables/rules.v4`.nothrow().quiet()
      if (rulesResult.exitCode === 0) {
        const rules = rulesResult.stdout.toString()
        return rules.includes('--dport 80') && rules.includes('8080')
      }
    }
    // Fallback: try sudo -n (non-interactive)
    const result = await $`sudo -n iptables -t nat -L OUTPUT -n 2>/dev/null`
      .nothrow()
      .quiet()
    if (result.exitCode === 0) {
      const rules = result.stdout.toString()
      return rules.includes('80') && rules.includes('8080')
    }
    return false
  } else if (platform === 'win32') {
    const result = await $`netsh interface portproxy show v4tov4`
      .nothrow()
      .quiet()
    if (result.exitCode === 0) {
      const output = result.stdout.toString()
      return output.includes('80') && output.includes('8080')
    }
    return false
  }

  return false
}

/**
 * Install persistent port forwarding rules (run once with sudo)
 * After running this, port 80 will forward to 8080 automatically
 */
export async function installPortForwarding(): Promise<boolean> {
  const platform = process.platform
  const targetPort = 8080

  console.log('üîß Installing persistent port forwarding (80 ‚Üí 8080)...\n')

  if (platform === 'darwin') {
    // macOS: Add rules to /etc/pf.anchors and configure pf.conf
    console.log('Platform: macOS (using pf)')
    console.log('')

    // Create anchor file with our rules
    const anchorContent = `# Jeju local development port forwarding
rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 80 -> 127.0.0.1 port ${targetPort}
rdr pass on lo0 inet proto tcp from any to any port 80 -> 127.0.0.1 port ${targetPort}
`
    const anchorPath = '/etc/pf.anchors/jeju'

    // Check if anchor file already exists with correct content
    let anchorNeedsUpdate = true
    if (existsSync(anchorPath)) {
      const existingContent = readFileSync(anchorPath, 'utf-8')
      if (existingContent.trim() === anchorContent.trim()) {
        anchorNeedsUpdate = false
        console.log('1. Checking anchor file...')
        console.log('   ‚úÖ /etc/pf.anchors/jeju already exists with correct content')
      }
    }

    if (anchorNeedsUpdate) {
      console.log('1. Creating anchor file...')
      const tempAnchor = '/tmp/jeju-pf-anchor'
      writeFileSync(tempAnchor, anchorContent)
      const copyResult = await $`sudo cp ${tempAnchor} ${anchorPath}`.nothrow()
      if (copyResult.exitCode !== 0) {
        console.error('   ‚ùå Failed to create anchor file')
        return false
      }
      console.log('   ‚úÖ Created /etc/pf.anchors/jeju')
    }

    // Check if pf.conf already has our anchor
    console.log('')
    console.log('2. Configuring pf.conf...')
    const pfConfResult = await $`cat /etc/pf.conf`.nothrow().quiet()
    const pfConf = pfConfResult.stdout.toString()

    if (!pfConf.includes('anchor "jeju"')) {
      // Add our anchor to pf.conf
      const newPfConf =
        pfConf.trimEnd() +
        `

# Jeju local development
rdr-anchor "jeju"
load anchor "jeju" from "/etc/pf.anchors/jeju"
`
      const tempPfConf = '/tmp/jeju-pf-conf'
      writeFileSync(tempPfConf, newPfConf)
      const updateResult = await $`sudo cp ${tempPfConf} /etc/pf.conf`.nothrow()
      if (updateResult.exitCode !== 0) {
        console.error('   ‚ùå Failed to update pf.conf')
        return false
      }
      console.log('   ‚úÖ Added jeju anchor to /etc/pf.conf')
    } else {
      console.log('   ‚úÖ Anchor already in pf.conf')
    }

    // Only reload pf if we made changes
    if (anchorNeedsUpdate || !pfConf.includes('anchor "jeju"')) {
      console.log('')
      console.log('3. Enabling packet filter...')
      await $`sudo pfctl -ef /etc/pf.conf`.nothrow()
      console.log('   ‚úÖ Packet filter enabled')
    } else {
      console.log('')
      console.log('3. Packet filter already configured')
    }

    console.log('')
    console.log('Port forwarding installed. Port 80 now forwards to 8080.')
    console.log('This persists across reboots on macOS.')
    return true
  } else if (platform === 'linux') {
    console.log('Platform: Linux (using iptables)')
    console.log('')

    console.log('1. Adding iptables rules...')
    // Add iptables rules
    await $`sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port ${targetPort}`.nothrow()
    await $`sudo iptables -t nat -A OUTPUT -o lo -p tcp --dport 80 -j REDIRECT --to-port ${targetPort}`.nothrow()
    console.log('   ‚úÖ iptables rules added')

    // Try to persist rules
    console.log('')
    console.log('2. Persisting rules...')
    const netfilterResult = await $`which netfilter-persistent`
      .nothrow()
      .quiet()
    if (netfilterResult.exitCode === 0) {
      await $`sudo netfilter-persistent save`.nothrow()
      console.log('   ‚úÖ Rules saved with netfilter-persistent')
    } else {
      const iptablesSaveResult = await $`which iptables-save`.nothrow().quiet()
      if (iptablesSaveResult.exitCode === 0) {
        await $`sudo iptables-save | sudo tee /etc/iptables/rules.v4`.nothrow()
        console.log('   ‚úÖ Rules saved to /etc/iptables/rules.v4')
      } else {
        console.log(
          '   ‚ö†Ô∏è  Install iptables-persistent to persist rules across reboots',
        )
        console.log('   Run: sudo apt install iptables-persistent')
      }
    }

    console.log('')
    console.log('Port forwarding installed. Port 80 now forwards to 8080.')
    return true
  } else if (platform === 'win32') {
    console.log('Platform: Windows (using netsh)')
    console.log('')

    console.log('1. Adding port forwarding rule...')
    const result =
      await $`netsh interface portproxy add v4tov4 listenport=80 listenaddress=127.0.0.1 connectport=${targetPort} connectaddress=127.0.0.1`.nothrow()

    if (result.exitCode !== 0) {
      console.error('   ‚ùå Failed to add port forwarding rule')
      console.log('   Try running this command as Administrator')
      return false
    }
    console.log('   ‚úÖ Port forwarding rule added')
    console.log('')
    console.log('Port forwarding installed. Port 80 now forwards to 8080.')
    console.log('This persists across reboots on Windows.')
    return true
  }

  console.error('Unsupported platform:', platform)
  return false
}

// CLI entry point
if (import.meta.main) {
  const command = process.argv[2]

  switch (command) {
    case 'start':
      await startProxy()
      break

    case 'stop':
      await stopProxy()
      console.log('‚úÖ Proxy stopped')
      break

    case 'urls':
      console.log('Local development URLs:')
      for (const [name, url] of Object.entries(getLocalUrls())) {
        console.log(`  ${name.padEnd(12)} ${url}`)
      }
      break

    case 'caddyfile':
      console.log(generateCaddyfile())
      break

    case 'hosts':
    case 'hosts:check': {
      const status = getHostsBlockStatus()
      if (status.exists) {
        console.log('‚úÖ Jeju hosts block found:\n')
        console.log(status.current)
      } else {
        console.log('‚ùå Jeju hosts block not found')
        console.log('\nExpected block:\n')
        console.log(status.expected)
        console.log(
          '\nRun: bun run packages/deployment/scripts/shared/local-proxy.ts hosts:add',
        )
      }
      break
    }

    case 'hosts:add':
      console.log('üìù Adding Jeju block to hosts file...\n')
      await ensureHostsFile()
      break

    case 'hosts:remove':
      console.log('üóëÔ∏è  Removing Jeju block from hosts file...\n')
      await removeHostsBlock()
      break

    case 'hosts:show':
      console.log(generateHostsBlock())
      break

    case 'setup':
      // Full setup - hosts + proxy
      await startProxy()
      break

    default:
      console.log(`
Jeju Local Proxy Manager

Usage: bun run packages/deployment/scripts/shared/local-proxy.ts <command>

Commands:
  start         Start the reverse proxy (with hosts check)
  stop          Stop the reverse proxy
  setup         Full setup (hosts + proxy)
  urls          Show available local URLs
  caddyfile     Print generated Caddyfile

Hosts Management:
  hosts         Check if Jeju block exists in hosts file
  hosts:add     Add Jeju block to hosts file (requires sudo)
  hosts:remove  Remove Jeju block from hosts file (requires sudo)
  hosts:show    Print the hosts block that would be added

Domain: ${DOMAIN}
Services: ${Object.keys(SERVICES).join(', ')}
`)
  }
}
