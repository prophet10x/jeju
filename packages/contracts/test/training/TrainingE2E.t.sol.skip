// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Test, console} from "forge-std/Test.sol";
import {TrainingCoordinator} from "../../src/training/TrainingCoordinator.sol";
import {ITrainingCoordinator} from "../../src/training/interfaces/ITrainingCoordinator.sol";
import {TrainingRewards} from "../../src/training/TrainingRewards.sol";
import {NodePerformanceOracle} from "../../src/training/NodePerformanceOracle.sol";
import {TrainingRegistry} from "../../src/training/TrainingRegistry.sol";
import {ComputeRegistry} from "../../src/compute/ComputeRegistry.sol";
import {MPCKeyRegistry} from "../../src/kms/MPCKeyRegistry.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract SimpleToken is ERC20 {
    constructor() ERC20("Reward", "RWD") {
        _mint(msg.sender, 100000 ether);
    }
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @title End-to-End Training Integration Test
 * @notice Tests the full training workflow from run creation to reward distribution
 */
contract TrainingE2ETest is Test {
    TrainingCoordinator coordinator;
    TrainingRewards rewards;
    NodePerformanceOracle oracle;
    TrainingRegistry registry;
    ComputeRegistry computeRegistry;
    MPCKeyRegistry mpcRegistry;
    SimpleToken rewardToken;

    address owner = address(this);
    address provider1 = makeAddr("provider1");
    address provider2 = makeAddr("provider2");
    address provider3 = makeAddr("provider3");

    bytes32 runId = bytes32(uint256(1));

    function setUp() public {
        // Deploy core dependencies
        computeRegistry = new ComputeRegistry(owner, address(0), address(0), 0.1 ether);
        mpcRegistry = new MPCKeyRegistry(0.01 ether);
        rewardToken = new SimpleToken();

        // Deploy training contracts
        coordinator = new TrainingCoordinator(
            address(computeRegistry),
            address(mpcRegistry),
            owner
        );
        rewards = new TrainingRewards(address(coordinator), owner);
        registry = new TrainingRegistry(
            address(coordinator),
            address(mpcRegistry),
            owner
        );
        oracle = new NodePerformanceOracle(
            address(coordinator),
            address(computeRegistry),
            owner
        );

        // Fund providers for staking
        vm.deal(provider1, 10 ether);
        vm.deal(provider2, 10 ether);
        vm.deal(provider3, 10 ether);

        // Register providers in ComputeRegistry
        vm.prank(provider1);
        computeRegistry.register{value: 0.1 ether}(
            "provider1",
            "node1.jeju.network",
            keccak256("gpu-123")
        );
        vm.prank(provider2);
        computeRegistry.register{value: 0.1 ether}(
            "provider2",
            "node2.jeju.network",
            keccak256("gpu-456")
        );
        vm.prank(provider3);
        computeRegistry.register{value: 0.1 ether}(
            "provider3",
            "node3.jeju.network",
            keccak256("gpu-789")
        );

        // Approve rewards token
        rewardToken.approve(address(rewards), 100000 ether);

        console.log("Setup complete");
        console.log("Coordinator:", address(coordinator));
        console.log("Rewards:", address(rewards));
        console.log("Oracle:", address(oracle));
    }

    function testFullTrainingWorkflow() public {
        console.log("\n=== FULL END-TO-END TRAINING TEST ===\n");

        // Step 1: Create training run
        console.log("Step 1: Creating training run...");
        ITrainingCoordinator.CoordinatorConfig memory config = ITrainingCoordinator.CoordinatorConfig({
            warmupTime: 60,
            cooldownTime: 30,
            maxRoundTrainTime: 120,
            roundWitnessTime: 60,
            epochTime: 600,
            globalBatchSizeWarmupTokens: 1000000,
            totalSteps: 1000,
            initMinClients: 3,
            minClients: 2,
            witnessNodes: 2,
            globalBatchSizeStart: 8,
            globalBatchSizeEnd: 32,
            verificationPercent: 10,
            waitingForMembersExtraTime: 60
        });
        ITrainingCoordinator.ModelConfig memory model = ITrainingCoordinator.ModelConfig({
            modelHash: bytes32(uint256(1)),
            hfRepo: "jeju/llama-7b",
            maxSeqLen: 2048,
            coldStartWarmupSteps: 100
        });

        coordinator.createRun(runId, config, model, ITrainingCoordinator.PrivacyMode.Public, bytes32(0));
        assertEq(uint256(coordinator.getRunState(runId)), uint256(ITrainingCoordinator.RunState.WaitingForMembers));
        console.log("  Run created in WaitingForMembers state");

        // Step 2: Providers join the run
        console.log("\nStep 2: Providers joining run...");
        vm.prank(provider1);
        coordinator.joinRun(runId, bytes32(uint256(101)));
        vm.prank(provider2);
        coordinator.joinRun(runId, bytes32(uint256(102)));
        vm.prank(provider3);
        coordinator.joinRun(runId, bytes32(uint256(103)));

        ITrainingCoordinator.Client[] memory clients = coordinator.getClients(runId);
        assertEq(clients.length, 3);
        console.log("  3 providers joined");

        // Step 3: Tick to start warmup
        console.log("\nStep 3: Ticking to Warmup...");
        coordinator.tick(runId);
        assertEq(uint256(coordinator.getRunState(runId)), uint256(ITrainingCoordinator.RunState.Warmup));
        console.log("  Transitioned to Warmup state");

        // Step 4: Submit warmup witnesses
        console.log("\nStep 4: Submitting warmup witnesses...");
        vm.prank(provider1);
        coordinator.submitWarmupWitness(runId, bytes32(uint256(1001)));
        vm.prank(provider2);
        coordinator.submitWarmupWitness(runId, bytes32(uint256(1002)));
        console.log("  Warmup witnesses submitted");

        // Step 5: Tick to start training round
        console.log("\nStep 5: Ticking to RoundTrain...");
        vm.warp(block.timestamp + 61);
        coordinator.tick(runId);
        assertEq(uint256(coordinator.getRunState(runId)), uint256(ITrainingCoordinator.RunState.RoundTrain));
        console.log("  Transitioned to RoundTrain state");

        // Step 6: Tick to witness phase
        console.log("\nStep 6: Ticking to RoundWitness...");
        vm.warp(block.timestamp + 121);
        coordinator.tick(runId);
        assertEq(uint256(coordinator.getRunState(runId)), uint256(TrainingCoordinator.RunState.RoundWitness));
        console.log("  Transitioned to RoundWitness state");

        // Step 7: Submit witnesses with gradient hashes
        console.log("\nStep 7: Submitting round witnesses...");
        bytes32 gradientHash = keccak256("gradient-data");
        vm.prank(provider1);
        coordinator.submitWitness(runId, gradientHash, keccak256(abi.encodePacked(gradientHash, provider1)));
        vm.prank(provider2);
        coordinator.submitWitness(runId, gradientHash, keccak256(abi.encodePacked(gradientHash, provider2)));
        console.log("  Round witnesses submitted");

        // Step 8: Create reward pool and claim rewards
        console.log("\nStep 8: Setting up rewards...");
        rewards.createRewardPool(runId, 1000 ether);

        // Simulate epoch completion by advancing state
        vm.warp(block.timestamp + 121);
        coordinator.tick(runId); // Should go to RoundTrain for epoch 2 or loop

        // Step 9: Register nodes in performance oracle
        console.log("\nStep 9: Registering nodes in performance oracle...");
        oracle.registerNode(
            provider1,
            NodePerformanceOracle.GPUTier.HighEnd, // H100
            1000, // bandwidthMbps
            100,  // latencyMs
            100   // initialScore
        );
        oracle.registerNode(
            provider2,
            NodePerformanceOracle.GPUTier.Datacenter, // A100
            500,
            150,
            80
        );

        // Step 10: Check node metrics and scores
        console.log("\nStep 10: Checking node metrics...");
        (
            NodePerformanceOracle.GPUTier tier1,
            uint256 bandwidth1,
            ,
            ,
            uint256 score1,
            ,
            bool active1
        ) = oracle.getNodeMetrics(provider1);
        
        assertEq(uint256(tier1), uint256(NodePerformanceOracle.GPUTier.HighEnd));
        assertEq(bandwidth1, 1000);
        assertGt(score1, 0);
        assertTrue(active1);
        console.log("  Provider1 score:", score1);

        // Step 11: Get optimal nodes for a new run
        console.log("\nStep 11: Getting optimal nodes...");
        address[] memory optimalNodes = oracle.getOptimalNodes(5, 100);
        console.log("  Optimal nodes count:", optimalNodes.length);

        console.log("\n=== END-TO-END TEST PASSED ===\n");
    }

    function testRewardDistribution() public {
        console.log("\n=== REWARD DISTRIBUTION TEST ===\n");

        // Create run and have providers join
        TrainingCoordinator.CoordinatorConfig memory config = TrainingCoordinator.CoordinatorConfig({
            minClients: 2,
            maxClients: 5,
            warmupTimeout: 60,
            roundTimeout: 120,
            healthCheckInterval: 300,
            witnessQuorum: 2,
            isPrivate: false,
            rewardToken: address(rewardToken)
        });
        TrainingCoordinator.ModelConfig memory model = TrainingCoordinator.ModelConfig({
            parameterCount: 1_000_000_000,
            batchSize: 128,
            sequenceLength: 1024,
            modelName: "test-model",
            baseWeightsHash: bytes32(uint256(1)),
            trainingDataHash: bytes32(uint256(2)),
            hyperparamsHash: bytes32(uint256(3))
        });

        bytes32 testRunId = bytes32(uint256(2));
        coordinator.createRun(testRunId, config, model);

        vm.prank(provider1);
        coordinator.joinRun(testRunId, bytes32(uint256(201)));
        vm.prank(provider2);
        coordinator.joinRun(testRunId, bytes32(uint256(202)));

        // Create reward pool
        rewards.createRewardPool(testRunId, 500 ether);

        // Record points for participants
        uint256[] memory points = new uint256[](2);
        points[0] = 100;
        points[1] = 50;
        address[] memory participants = new address[](2);
        participants[0] = provider1;
        participants[1] = provider2;
        rewards.recordPoints(testRunId, participants, points, 1);

        // Check claimable amounts
        (uint256 claimable1,) = rewards.claimable(testRunId, provider1);
        (uint256 claimable2,) = rewards.claimable(testRunId, provider2);
        
        console.log("Provider1 claimable:", claimable1);
        console.log("Provider2 claimable:", claimable2);

        // Provider1 should get 2/3 of rewards, Provider2 gets 1/3
        assertGt(claimable1, claimable2);

        // Claim rewards
        uint256 balanceBefore = rewardToken.balanceOf(provider1);
        vm.prank(provider1);
        rewards.claim(testRunId);
        uint256 balanceAfter = rewardToken.balanceOf(provider1);

        assertEq(balanceAfter - balanceBefore, claimable1);
        console.log("Provider1 claimed:", claimable1);

        console.log("\n=== REWARD DISTRIBUTION TEST PASSED ===\n");
    }

    function testNodePerformanceTracking() public {
        console.log("\n=== NODE PERFORMANCE TRACKING TEST ===\n");

        // Register nodes with different specs
        oracle.registerNode(
            provider1,
            NodePerformanceOracle.GPUTier.HighEnd, // H100-class
            2000,
            50,
            100
        );
        oracle.registerNode(
            provider2,
            NodePerformanceOracle.GPUTier.Datacenter, // A100-class
            1000,
            100,
            80
        );
        oracle.registerNode(
            provider3,
            NodePerformanceOracle.GPUTier.Prosumer, // 4090-class
            500,
            150,
            60
        );

        // Check initial scores
        uint256 score1 = oracle.getNodeScore(provider1);
        uint256 score2 = oracle.getNodeScore(provider2);
        uint256 score3 = oracle.getNodeScore(provider3);

        console.log("Initial scores:");
        console.log("  H100 node:", score1);
        console.log("  A100 node:", score2);
        console.log("  4090 node:", score3);

        assertTrue(score1 > score2, "H100 should score higher than A100");
        assertTrue(score2 > score3, "A100 should score higher than 4090");

        // Update metrics with performance data
        oracle.updateMetrics(provider1, 2100, 45, 95);
        oracle.updateMetrics(provider2, 900, 120, 75);

        // Check updated scores
        uint256 updatedScore1 = oracle.getNodeScore(provider1);
        uint256 updatedScore2 = oracle.getNodeScore(provider2);

        console.log("\nUpdated scores:");
        console.log("  H100 node:", updatedScore1);
        console.log("  A100 node:", updatedScore2);

        // Get optimal nodes with bandwidth filter
        address[] memory highBandwidthNodes = oracle.getOptimalNodes(3, 1000);
        console.log("\nHigh bandwidth nodes count:", highBandwidthNodes.length);

        // H100 node should be in the high bandwidth list
        bool foundH100 = false;
        for (uint i = 0; i < highBandwidthNodes.length; i++) {
            if (highBandwidthNodes[i] == provider1) {
                foundH100 = true;
                break;
            }
        }
        assertTrue(foundH100, "H100 node should be in optimal nodes");

        console.log("\n=== NODE PERFORMANCE TRACKING TEST PASSED ===\n");
    }
}

