/** Local development proxy with Caddy */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import { CORE_PORTS, INFRA_PORTS } from '@jejunetwork/config'
import { $ } from 'bun'
import { discoverAllApps } from './discover-apps'

const DOMAIN = 'local.jejunetwork.org'
const CADDY_DIR = '.jeju/caddy'
const CADDYFILE_PATH = `${CADDY_DIR}/Caddyfile`
const PID_FILE = `${CADDY_DIR}/caddy.pid`

// Hosts file block markers
const HOSTS_BLOCK_START = '# JEJU LOCAL DEV START'
const HOSTS_BLOCK_END = '# JEJU LOCAL DEV END'

/**
 * Slugify a display name to match how dev.ts generates URLs
 * "Gateway" -> "gateway"
 * "Autocrat" -> "autocrat"
 */
function slugifyDisplayName(displayName: string): string {
  return displayName.toLowerCase().replace(/\s+/g, '-')
}

/**
 * Get the primary port for an app from its manifest
 * Priority: frontend > main > first available port
 * Frontend port is preferred when defined (some apps have separate frontend/api)
 */
function getPrimaryPort(
  ports: Record<string, number> | undefined,
): number | undefined {
  if (!ports) return undefined
  // Prefer frontend port when defined - some apps have separate UI/API servers
  if (ports.frontend) return ports.frontend
  if (ports.main) return ports.main
  // Skip 'api' - we want the user-facing port
  const allPorts = Object.values(ports)
  return allPorts.length > 0 ? allPorts[0] : undefined
}

/**
 * Build service mappings from discovered apps and infrastructure ports
 * Uses slugified display names to match how URLs are generated in dev.ts
 */
function buildServicesFromApps(): Record<string, number> {
  const services: Record<string, number> = {}

  // Add infrastructure services (these use short names)
  services.rpc = INFRA_PORTS.L2_RPC.get()
  services.ws = INFRA_PORTS.L2_WS.get()

  // Discover apps and use their slugified display names
  const apps = discoverAllApps()
  for (const app of apps) {
    const port = getPrimaryPort(app.manifest.ports)
    if (port) {
      const displayName = app.manifest.displayName || app.name
      const slug = slugifyDisplayName(displayName)
      services[slug] = port

      if (app.name !== slug) {
        services[app.name] = port
      }
    }
  }

  // Add any core services that might not have manifests
  if (!services.ipfs) services.ipfs = CORE_PORTS.IPFS.get()
  if (!services.compute) services.compute = CORE_PORTS.COMPUTE.get()

  // DWS services - git and pkg are DWS endpoints, all on port 4030
  const dwsPort = 4030
  services.dws = dwsPort
  services.git = dwsPort
  services.pkg = dwsPort

  return services
}

// Build services dynamically from apps
const SERVICES: Record<string, number> = buildServicesFromApps()

interface ProxyConfig {
  services?: Partial<typeof SERVICES>
  domain?: string
  port?: number
}

// Hosts File Management

function getHostsFilePath(): string {
  if (process.platform === 'win32') {
    return 'C:\\Windows\\System32\\drivers\\etc\\hosts'
  }
  return '/etc/hosts'
}

function generateHostsBlock(config: ProxyConfig = {}): string {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }

  const lines: string[] = [
    HOSTS_BLOCK_START,
    '# Auto-generated by Jeju - do not edit manually',
    `# Domain: ${domain}`,
    '',
    '# IPv4 entries',
  ]

  lines.push(`127.0.0.1  ${domain}`)

  for (const service of Object.keys(services)) {
    lines.push(`127.0.0.1  ${service}.${domain}`)
  }

  lines.push('')
  lines.push('# IPv6 entries (for apps that bind to ::1)')
  lines.push(`::1  ${domain}`)
  for (const service of Object.keys(services)) {
    lines.push(`::1  ${service}.${domain}`)
  }

  lines.push('')
  lines.push(HOSTS_BLOCK_END)

  return lines.join('\n')
}

function readHostsFile(): string {
  const hostsPath = getHostsFilePath()
  if (!existsSync(hostsPath)) {
    return ''
  }
  return readFileSync(hostsPath, 'utf-8')
}

export function hasJejuHostsBlock(): boolean {
  const content = readHostsFile()
  return (
    content.includes(HOSTS_BLOCK_START) && content.includes(HOSTS_BLOCK_END)
  )
}

export function getHostsBlockStatus(): {
  exists: boolean
  current: string
  expected: string
  missingDomains: string[]
} {
  const content = readHostsFile()
  const expected = generateHostsBlock()

  if (!content.includes(HOSTS_BLOCK_START)) {
    return { exists: false, current: '', expected, missingDomains: [] }
  }

  const startIdx = content.indexOf(HOSTS_BLOCK_START)
  const endIdx = content.indexOf(HOSTS_BLOCK_END)

  if (endIdx === -1) {
    return { exists: false, current: '', expected, missingDomains: [] }
  }

  const current = content.substring(startIdx, endIdx + HOSTS_BLOCK_END.length)

  const missingDomains: string[] = []
  const expectedLines = expected.split('\n')
  for (const line of expectedLines) {
    if (line.startsWith('127.0.0.1')) {
      const domain = line.split(/\s+/)[1]
      if (domain && !current.includes(domain)) {
        missingDomains.push(domain)
      }
    }
  }

  return { exists: true, current, expected, missingDomains }
}

export async function ensureHostsFile(
  config: ProxyConfig = {},
  options: { force?: boolean } = {},
): Promise<boolean> {
  const hostsPath = getHostsFilePath()

  const status = getHostsBlockStatus()
  const expectedBlock = generateHostsBlock(config)

  if (status.exists && status.missingDomains.length === 0) {
    console.log('   ‚úÖ Hosts file already configured')
    return true
  }

  if (status.exists && !options.force) {
    if (status.missingDomains.length > 0) {
      console.log(
        `   ‚ö†Ô∏è  Hosts file has ${status.missingDomains.length} missing domain(s) - run 'jeju proxy hosts:add' to update`,
      )
    }
    console.log('   ‚úÖ Hosts file configured (partial)')
    return true
  }

  if (status.exists) {
    console.log(
      `   üîÑ Hosts file missing ${status.missingDomains.length} domain(s): ${status.missingDomains.slice(0, 3).join(', ')}${status.missingDomains.length > 3 ? '...' : ''}`,
    )
  } else {
    console.log('   üìù Jeju entries not found in hosts file')
  }

  let content = readHostsFile()

  if (status.exists) {
    const startIdx = content.indexOf(HOSTS_BLOCK_START)
    const endIdx = content.indexOf(HOSTS_BLOCK_END) + HOSTS_BLOCK_END.length
    content = content.substring(0, startIdx) + content.substring(endIdx)
  }

  content = `${content.trimEnd()}\n\n${expectedBlock}\n`

  const tempFile = '/tmp/jeju-hosts-update'
  writeFileSync(tempFile, content)

  const platform = process.platform

  if (platform === 'win32') {
    console.log('   ‚ö†Ô∏è  Windows detected - need Administrator privileges')
    console.log(`   Run this command in an Administrator PowerShell:`)
    console.log(`   Copy-Item "${tempFile}" -Destination "${hostsPath}"`)
    console.log('')
    console.log('   Or manually add these lines to your hosts file:')
    console.log(expectedBlock)
    return false
  }

  console.log('   üîê Requesting sudo access to write hosts file...')

  const result = await $`sudo cp ${tempFile} ${hostsPath}`.nothrow()

  if (result.exitCode !== 0) {
    console.error('   ‚ùå Failed to update hosts file')
    console.log('')
    console.log(`   To fix manually, add these lines to ${hostsPath}:`)
    console.log(expectedBlock)
    return false
  }

  await $`rm ${tempFile}`.nothrow().quiet()

  console.log('   ‚úÖ Hosts file updated')
  return true
}

export async function removeHostsBlock(): Promise<boolean> {
  const status = getHostsBlockStatus()

  if (!status.exists) {
    console.log('   ‚ÑπÔ∏è  No Jeju block in hosts file')
    return true
  }

  const hostsPath = getHostsFilePath()
  let content = readHostsFile()

  const startIdx = content.indexOf(HOSTS_BLOCK_START)
  const endIdx = content.indexOf(HOSTS_BLOCK_END) + HOSTS_BLOCK_END.length
  content = content.substring(0, startIdx) + content.substring(endIdx)

  content = `${content.replace(/\n{3,}/g, '\n\n').trim()}\n`

  const tempFile = '/tmp/jeju-hosts-remove'
  writeFileSync(tempFile, content)

  if (process.platform === 'win32') {
    console.log('   ‚ö†Ô∏è  Run in Administrator PowerShell:')
    console.log(`   Copy-Item "${tempFile}" -Destination "${hostsPath}"`)
    return false
  }

  console.log('   üîê Requesting sudo access to update hosts file...')
  const result = await $`sudo cp ${tempFile} ${hostsPath}`.nothrow()

  await $`rm ${tempFile}`.nothrow().quiet()

  if (result.exitCode !== 0) {
    console.error('   ‚ùå Failed to remove hosts block')
    return false
  }

  console.log('   ‚úÖ Hosts block removed')
  return true
}

// Caddy Proxy Management

export async function isCaddyInstalled(): Promise<boolean> {
  const result = await $`which caddy`.nothrow().quiet()
  return result.exitCode === 0
}

export async function installCaddy(): Promise<boolean> {
  const platform = process.platform

  console.log('üì¶ Installing Caddy...')

  if (platform === 'darwin') {
    const result = await $`brew install caddy`.nothrow()
    return result.exitCode === 0
  } else if (platform === 'linux') {
    let result = await $`which apt-get`.nothrow().quiet()
    if (result.exitCode === 0) {
      await $`sudo apt-get update`.nothrow().quiet()
      result = await $`sudo apt-get install -y caddy`.nothrow()
      return result.exitCode === 0
    }

    result = await $`which dnf`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`sudo dnf install -y caddy`.nothrow()
      return result.exitCode === 0
    }

    console.log('   Downloading Caddy binary...')
    const arch = process.arch === 'x64' ? 'amd64' : 'arm64'
    const url = `https://caddyserver.com/api/download?os=linux&arch=${arch}`
    result =
      await $`curl -fsSL ${url} -o /tmp/caddy && chmod +x /tmp/caddy && sudo mv /tmp/caddy /usr/local/bin/caddy`.nothrow()
    return result.exitCode === 0
  } else if (platform === 'win32') {
    let result = await $`where scoop`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`scoop install caddy`.nothrow()
      return result.exitCode === 0
    }

    result = await $`where choco`.nothrow().quiet()
    if (result.exitCode === 0) {
      result = await $`choco install caddy -y`.nothrow()
      return result.exitCode === 0
    }

    console.error(
      '   Please install Caddy manually: https://caddyserver.com/docs/install#windows',
    )
    return false
  }

  return false
}

/**
 * Format URL with or without port
 * Port 80 is omitted (standard HTTP), other ports are included
 */
function formatUrl(subdomain: string, domain: string, port: number): string {
  if (port === 80) {
    return subdomain ? `http://${subdomain}.${domain}` : `http://${domain}`
  }
  return subdomain
    ? `http://${subdomain}.${domain}:${port}`
    : `http://${domain}:${port}`
}

// Services that should bypass JNS and route directly to their ports
// These are infrastructure services, not deployable apps
const DIRECT_ROUTE_SERVICES = new Set([
  'rpc',
  'ws',
  'ipfs',
  'compute',
  'indexer',
  'git', // JejuGit - routes to DWS
  'pkg', // JejuPkg - routes to DWS
  // Note: 'dws' is NOT here - it has a frontend served via JNS Gateway
])

// Services that need hybrid routing (frontend + API on same domain)
// Frontend served from JNS Gateway, API paths routed to backend
const HYBRID_SERVICES: Record<string, { port: number; apiPaths: string[] }> = {
  dws: {
    port: 4030,
    apiPaths: [
      '/storage/*',
      '/compute/*',
      '/cdn/*',
      '/git/*',
      '/pkg/*',
      '/ci/*',
      '/oauth3/*',
      '/api/*',
      '/a2a/*',
      '/mcp/*',
      '/s3/*',
      '/workers/*',
      '/workerd/*',
      '/kms/*',
      '/vpn/*',
      '/scraping/*',
      '/rpc/*',
      '/edge/*',
      '/da/*',
      '/funding/*',
      '/registry/*',
      '/k3s/*',
      '/helm/*',
      '/terraform/*',
      '/ingress/*',
      '/mesh/*',
      '/containers/*',
    ],
  },
}

export function generateCaddyfile(config: ProxyConfig = {}): string {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }
  // Use port 80 by default for clean URLs (requires sudo on Unix)
  const proxyPort = config.port || 80
  // JNS Gateway port for app content from IPFS
  // Note: Port 4302 is used by JNS resolution service, gateway is on 4303
  const jnsGatewayPort = 4303

  const entries: string[] = [
    '# Auto-generated Caddyfile for local development',
    '# Do not edit - regenerated on each `bun run dev`',
    '',
    '# Global options',
    '{',
    '    # Disable HTTPS for local development',
    '    auto_https off',
    '}',
    '',
  ]

  // Landing page - use http:// prefix to explicitly disable TLS
  // Generate an HTML landing page with clickable links
  const serviceLinks = Object.keys(services)
    .map(
      (s) => `<li><a href="${formatUrl(s, domain, proxyPort)}">${s}</a></li>`,
    )
    .join('')

  const landingHtml = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeju Local Development</title>
  <style>
    :root { --bg: #0a0a0a; --fg: #fafafa; --accent: #10b981; --border: #262626; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--fg); min-height: 100vh; padding: 2rem; }
    .container { max-width: 800px; margin: 0 auto; }
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    .subtitle { color: #737373; margin-bottom: 2rem; }
    .services { display: grid; gap: 0.5rem; }
    .services a { display: block; padding: 0.75rem 1rem; background: #171717; border: 1px solid var(--border); border-radius: 0.5rem; color: var(--accent); text-decoration: none; transition: all 0.15s; }
    .services a:hover { background: #262626; border-color: var(--accent); }
    .footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border); color: #525252; font-size: 0.875rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Jeju Local Development</h1>
    <p class="subtitle">Available services on ${domain}</p>
    <ul class="services">${serviceLinks}</ul>
    <div class="footer">Running on port ${proxyPort}</div>
  </div>
</body>
</html>`

  entries.push(`# Landing page at ${domain}`)
  entries.push(`http://:${proxyPort} {`)
  entries.push(`    header Content-Type text/html`)
  entries.push(`    respond \`${landingHtml.replace(/`/g, '\\`')}\` 200`)
  entries.push(`}`)
  entries.push('')

  // DWS sub-services that need path rewriting
  // git.local.jejunetwork.org/* -> localhost:4030/git/*
  // pkg.local.jejunetwork.org/* -> localhost:4030/pkg/*
  const DWS_PATH_SERVICES: Record<string, string> = {
    git: '/git',
    pkg: '/pkg',
  }
  const dwsPort = 4030

  // Service routes with proper reverse proxy config
  // Use http:// prefix to explicitly disable TLS for each route
  for (const [service, port] of Object.entries(services)) {
    entries.push(`# ${service}`)
    entries.push(`http://${service}.${domain}:${proxyPort} {`)

    // DWS sub-services need path rewriting
    if (DWS_PATH_SERVICES[service]) {
      const basePath = DWS_PATH_SERVICES[service]
      entries.push(`    rewrite * ${basePath}{uri}`)
      entries.push(`    reverse_proxy localhost:${dwsPort}`)
    } else if (HYBRID_SERVICES[service]) {
      // Hybrid services: API paths to backend, everything else to JNS Gateway
      const hybrid = HYBRID_SERVICES[service]
      for (const apiPath of hybrid.apiPaths) {
        entries.push(`    handle ${apiPath} {`)
        entries.push(`        reverse_proxy localhost:${hybrid.port}`)
        entries.push(`    }`)
      }
      entries.push(`    handle {`)
      entries.push(`        reverse_proxy localhost:${jnsGatewayPort}`)
      entries.push(`    }`)
    } else if (DIRECT_ROUTE_SERVICES.has(service)) {
      // Infrastructure services route directly to their ports
      entries.push(`    reverse_proxy localhost:${port}`)
    } else {
      // Route app subdomains to JNS Gateway for IPFS content
      entries.push(`    reverse_proxy localhost:${jnsGatewayPort}`)
    }

    entries.push(`}`)
    entries.push('')
  }

  return entries.join('\n')
}

/**
 * Check if sudo credentials are cached (passwordless sudo available)
 */
async function hasSudoAccess(): Promise<boolean> {
  const result = await $`sudo -n true`.nothrow().quiet()
  return result.exitCode === 0
}

/**
 * Prompt user to authenticate sudo if needed
 * Must be run before background processes start
 * Returns true if sudo is available, false otherwise
 */
export async function ensureSudoAccess(): Promise<boolean> {
  if (process.platform === 'win32') {
    return true // Windows uses different elevation
  }

  // Only check if credentials are already cached - don't prompt
  // User should run `sudo -v` manually before `bun run dev` for port 80
  return hasSudoAccess()
}

/**
 * Set up port forwarding from port 80 to the Caddy port (8080)
 * This allows clean URLs without running Caddy as root
 *
 * - macOS: Uses pf (Packet Filter)
 * - Linux: Uses iptables
 * - Windows: Uses netsh portproxy
 */
async function setupPortForwarding(targetPort: number): Promise<boolean> {
  const platform = process.platform

  if (platform === 'darwin') {
    // macOS: Use pf (Packet Filter)
    const pfRules = `
rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 80 -> 127.0.0.1 port ${targetPort}
rdr pass on lo0 inet proto tcp from any to any port 80 -> 127.0.0.1 port ${targetPort}
`
    const pfFile = '/tmp/jeju-pf-rules.conf'
    writeFileSync(pfFile, pfRules)

    // Enable pf and load rules
    const result = await $`sudo -n pfctl -ef ${pfFile}`.nothrow().quiet()
    if (result.exitCode !== 0) {
      // pf might already be enabled, just load the rules
      await $`sudo -n pfctl -e 2>&1 || true`.nothrow().quiet()
      const loadResult = await $`sudo -n pfctl -f ${pfFile}`.nothrow().quiet()
      if (loadResult.exitCode !== 0) {
        console.log('   ‚ö†Ô∏è  Could not set up port forwarding (sudo required)')
        return false
      }
    }
    return true
  } else if (platform === 'linux') {
    // Linux: Use iptables
    const result =
      await $`sudo -n iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port ${targetPort}`
        .nothrow()
        .quiet()
    if (result.exitCode !== 0) {
      // Also add for localhost
      await $`sudo -n iptables -t nat -A OUTPUT -o lo -p tcp --dport 80 -j REDIRECT --to-port ${targetPort}`
        .nothrow()
        .quiet()
    }
    return result.exitCode === 0
  } else if (platform === 'win32') {
    // Windows: Use netsh portproxy
    const result =
      await $`netsh interface portproxy add v4tov4 listenport=80 listenaddress=127.0.0.1 connectport=${targetPort} connectaddress=127.0.0.1`
        .nothrow()
        .quiet()
    return result.exitCode === 0
  }

  return false
}

/**
 * Remove port forwarding rules
 */
async function removePortForwarding(): Promise<void> {
  const platform = process.platform

  if (platform === 'darwin') {
    await $`sudo -n pfctl -F all`.nothrow().quiet()
  } else if (platform === 'linux') {
    await $`sudo -n iptables -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080`
      .nothrow()
      .quiet()
    await $`sudo -n iptables -t nat -D OUTPUT -o lo -p tcp --dport 80 -j REDIRECT --to-port 8080`
      .nothrow()
      .quiet()
  } else if (platform === 'win32') {
    await $`netsh interface portproxy delete v4tov4 listenport=80 listenaddress=127.0.0.1`
      .nothrow()
      .quiet()
  }
}

/**
 * Check if port forwarding is already set up
 */
export async function isPortForwardingActive(): Promise<boolean> {
  const platform = process.platform

  if (platform === 'darwin') {
    // Check if pf has our rules loaded
    const result = await $`sudo -n pfctl -sr 2>/dev/null`.nothrow().quiet()
    if (result.exitCode === 0) {
      const rules = result.stdout.toString()
      return rules.includes('port 80') && rules.includes('port 8080')
    }
    return false
  } else if (platform === 'linux') {
    const result = await $`sudo -n iptables -t nat -L OUTPUT -n 2>/dev/null`
      .nothrow()
      .quiet()
    if (result.exitCode === 0) {
      const rules = result.stdout.toString()
      return rules.includes('80') && rules.includes('8080')
    }
    return false
  } else if (platform === 'win32') {
    const result = await $`netsh interface portproxy show v4tov4`
      .nothrow()
      .quiet()
    if (result.exitCode === 0) {
      const output = result.stdout.toString()
      return output.includes('80') && output.includes('8080')
    }
    return false
  }

  return false
}

/**
 * Install persistent port forwarding rules (run once with sudo)
 * After running this, port 80 will forward to 8080 automatically
 */
export async function installPortForwarding(): Promise<boolean> {
  const platform = process.platform
  const targetPort = 8080

  console.log('üîß Installing persistent port forwarding (80 ‚Üí 8080)...\n')

  if (platform === 'darwin') {
    // macOS: Add rules to /etc/pf.anchors and configure pf.conf
    console.log('Platform: macOS (using pf)')
    console.log('')

    // Create anchor file with our rules
    const anchorContent = `# Jeju local development port forwarding
rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 80 -> 127.0.0.1 port ${targetPort}
rdr pass on lo0 inet proto tcp from any to any port 80 -> 127.0.0.1 port ${targetPort}
`
    const anchorPath = '/etc/pf.anchors/jeju'

    console.log('1. Creating anchor file...')
    const tempAnchor = '/tmp/jeju-pf-anchor'
    writeFileSync(tempAnchor, anchorContent)
    const copyResult = await $`sudo cp ${tempAnchor} ${anchorPath}`.nothrow()
    if (copyResult.exitCode !== 0) {
      console.error('   ‚ùå Failed to create anchor file')
      return false
    }
    console.log('   ‚úÖ Created /etc/pf.anchors/jeju')

    // Check if pf.conf already has our anchor
    console.log('')
    console.log('2. Configuring pf.conf...')
    const pfConfResult = await $`cat /etc/pf.conf`.nothrow().quiet()
    const pfConf = pfConfResult.stdout.toString()

    if (!pfConf.includes('anchor "jeju"')) {
      // Add our anchor to pf.conf
      const newPfConf =
        pfConf.trimEnd() +
        `

# Jeju local development
rdr-anchor "jeju"
load anchor "jeju" from "/etc/pf.anchors/jeju"
`
      const tempPfConf = '/tmp/jeju-pf-conf'
      writeFileSync(tempPfConf, newPfConf)
      const updateResult = await $`sudo cp ${tempPfConf} /etc/pf.conf`.nothrow()
      if (updateResult.exitCode !== 0) {
        console.error('   ‚ùå Failed to update pf.conf')
        return false
      }
      console.log('   ‚úÖ Added jeju anchor to /etc/pf.conf')
    } else {
      console.log('   ‚úÖ Anchor already in pf.conf')
    }

    // Enable and load pf
    console.log('')
    console.log('3. Enabling packet filter...')
    await $`sudo pfctl -ef /etc/pf.conf`.nothrow()
    console.log('   ‚úÖ Packet filter enabled')

    console.log('')
    console.log('Port forwarding installed. Port 80 now forwards to 8080.')
    console.log('This persists across reboots on macOS.')
    return true
  } else if (platform === 'linux') {
    console.log('Platform: Linux (using iptables)')
    console.log('')

    console.log('1. Adding iptables rules...')
    // Add iptables rules
    await $`sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port ${targetPort}`.nothrow()
    await $`sudo iptables -t nat -A OUTPUT -o lo -p tcp --dport 80 -j REDIRECT --to-port ${targetPort}`.nothrow()
    console.log('   ‚úÖ iptables rules added')

    // Try to persist rules
    console.log('')
    console.log('2. Persisting rules...')
    const netfilterResult = await $`which netfilter-persistent`
      .nothrow()
      .quiet()
    if (netfilterResult.exitCode === 0) {
      await $`sudo netfilter-persistent save`.nothrow()
      console.log('   ‚úÖ Rules saved with netfilter-persistent')
    } else {
      const iptablesSaveResult = await $`which iptables-save`.nothrow().quiet()
      if (iptablesSaveResult.exitCode === 0) {
        await $`sudo iptables-save | sudo tee /etc/iptables/rules.v4`.nothrow()
        console.log('   ‚úÖ Rules saved to /etc/iptables/rules.v4')
      } else {
        console.log(
          '   ‚ö†Ô∏è  Install iptables-persistent to persist rules across reboots',
        )
        console.log('   Run: sudo apt install iptables-persistent')
      }
    }

    console.log('')
    console.log('Port forwarding installed. Port 80 now forwards to 8080.')
    return true
  } else if (platform === 'win32') {
    console.log('Platform: Windows (using netsh)')
    console.log('')

    console.log('1. Adding port forwarding rule...')
    const result =
      await $`netsh interface portproxy add v4tov4 listenport=80 listenaddress=127.0.0.1 connectport=${targetPort} connectaddress=127.0.0.1`.nothrow()

    if (result.exitCode !== 0) {
      console.error('   ‚ùå Failed to add port forwarding rule')
      console.log('   Try running this command as Administrator')
      return false
    }
    console.log('   ‚úÖ Port forwarding rule added')
    console.log('')
    console.log('Port forwarding installed. Port 80 now forwards to 8080.')
    console.log('This persists across reboots on Windows.')
    return true
  }

  console.error('Unsupported platform:', platform)
  return false
}

/**
 * Remove persistent port forwarding rules
 */
export async function uninstallPortForwarding(): Promise<boolean> {
  const platform = process.platform

  console.log('üîß Removing port forwarding...\n')

  if (platform === 'darwin') {
    console.log('Platform: macOS')

    // Remove anchor from pf.conf
    const pfConfResult = await $`cat /etc/pf.conf`.nothrow().quiet()
    const pfConf = pfConfResult.stdout.toString()

    if (pfConf.includes('anchor "jeju"')) {
      const newPfConf = pfConf
        .split('\n')
        .filter(
          (line) =>
            !line.includes('# Jeju local development') &&
            !line.includes('anchor "jeju"') &&
            !line.includes('jeju'),
        )
        .join('\n')
        .replace(/\n{3,}/g, '\n\n')

      const tempPfConf = '/tmp/jeju-pf-conf-remove'
      writeFileSync(tempPfConf, newPfConf)
      await $`sudo cp ${tempPfConf} /etc/pf.conf`.nothrow()
      console.log('   ‚úÖ Removed anchor from pf.conf')
    }

    // Remove anchor file
    await $`sudo rm -f /etc/pf.anchors/jeju`.nothrow()
    console.log('   ‚úÖ Removed /etc/pf.anchors/jeju')

    // Reload pf
    await $`sudo pfctl -f /etc/pf.conf`.nothrow()
    console.log('   ‚úÖ Reloaded packet filter')

    return true
  } else if (platform === 'linux') {
    console.log('Platform: Linux')

    await $`sudo iptables -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080`.nothrow()
    await $`sudo iptables -t nat -D OUTPUT -o lo -p tcp --dport 80 -j REDIRECT --to-port 8080`.nothrow()
    console.log('   ‚úÖ Removed iptables rules')

    // Try to persist
    const netfilterResult = await $`which netfilter-persistent`
      .nothrow()
      .quiet()
    if (netfilterResult.exitCode === 0) {
      await $`sudo netfilter-persistent save`.nothrow()
    }

    return true
  } else if (platform === 'win32') {
    console.log('Platform: Windows')

    await $`netsh interface portproxy delete v4tov4 listenport=80 listenaddress=127.0.0.1`.nothrow()
    console.log('   ‚úÖ Removed port forwarding rule')

    return true
  }

  return false
}

export async function startProxy(config: ProxyConfig = {}): Promise<boolean> {
  const domain = config.domain || DOMAIN
  // We always run Caddy on 8080 and use port forwarding for 80
  const caddyPort = 8080
  const userFacingPort = config.port || 80
  const usePortForwarding =
    userFacingPort === 80 && process.platform !== 'win32'

  console.log(`üåê Setting up local proxy for ${domain}...\n`)

  console.log('1. Checking hosts file...')
  const hostsOk = await ensureHostsFile(config)
  if (!hostsOk) {
    console.log('   ‚ö†Ô∏è  Hosts file not configured - URLs will not resolve')
    console.log('   You can still access services at localhost:PORT\n')
  }
  console.log('')

  console.log('2. Checking Caddy installation...')
  if (!(await isCaddyInstalled())) {
    console.log('   ‚ö†Ô∏è  Caddy not installed')
    const installed = await installCaddy()
    if (!installed) {
      console.error('   ‚ùå Failed to install Caddy')
      console.error(
        '   Local proxy disabled - apps available at localhost ports',
      )
      return false
    }
    console.log('   ‚úÖ Caddy installed')
  } else {
    console.log('   ‚úÖ Caddy available')
  }
  console.log('')

  if (!existsSync(CADDY_DIR)) {
    mkdirSync(CADDY_DIR, { recursive: true })
  }

  await stopProxy()

  // Always run Caddy on 8080, then optionally forward port 80 ‚Üí 8080
  const caddyConfig = { ...config, port: caddyPort }
  let actualPort = caddyPort

  console.log('3. Generating Caddy configuration...')
  const caddyfile = generateCaddyfile(caddyConfig)
  writeFileSync(CADDYFILE_PATH, caddyfile)
  console.log('   ‚úÖ Caddyfile written')
  console.log('')

  console.log('4. Starting reverse proxy...')

  // Start Caddy on unprivileged port (no sudo needed)
  const proc = Bun.spawn(['caddy', 'run', '--config', CADDYFILE_PATH], {
    cwd: process.cwd(),
    stdout: 'pipe',
    stderr: 'pipe',
  })

  writeFileSync(PID_FILE, String(proc.pid))
  await Bun.sleep(500)

  if (proc.exitCode !== null) {
    const stderrStream = proc.stderr
    const stderr =
      stderrStream instanceof ReadableStream
        ? await new Response(stderrStream).text()
        : ''
    console.error('   ‚ùå Proxy failed to start:', stderr)
    return false
  }

  console.log(`   ‚úÖ Caddy running on port ${caddyPort}`)

  // Set up port forwarding for port 80 if requested
  if (usePortForwarding) {
    console.log('')
    console.log('5. Checking port forwarding (80 ‚Üí 8080)...')

    // First check if persistent forwarding is already set up
    if (await isPortForwardingActive()) {
      console.log('   ‚úÖ Port forwarding already active')
      actualPort = 80
    } else if (await hasSudoAccess()) {
      // Try to set up temporary forwarding
      const forwarded = await setupPortForwarding(caddyPort)
      if (forwarded) {
        console.log('   ‚úÖ Port 80 forwarded to 8080')
        actualPort = 80
      } else {
        console.log('   ‚ö†Ô∏è  Port forwarding failed - using port 8080')
      }
    } else {
      console.log('   ‚ö†Ô∏è  Port forwarding not set up - using port 8080')
      console.log('   Tip: Run "jeju proxy install" once to enable port 80')
    }
  }
  console.log('')

  // Generate URLs with the actual port being used
  const urlConfig = { ...config, port: actualPort }
  console.log('üéâ Local proxy ready. Available URLs:')
  const urls = getLocalUrls(urlConfig)
  for (const [name, url] of Object.entries(urls)) {
    console.log(`   ${name.padEnd(12)} ${url}`)
  }
  console.log('')

  return true
}

export async function stopProxy(): Promise<void> {
  if (existsSync(PID_FILE)) {
    const pid = parseInt(await Bun.file(PID_FILE).text(), 10)
    if (pid) {
      await $`kill ${pid}`.nothrow().quiet()
    }
    // File may have been deleted by another process between check and unlink
    await $`rm -f ${PID_FILE}`.nothrow().quiet()
  }

  // Kill any Caddy processes using our config file
  await $`pkill -f "caddy run --config ${CADDYFILE_PATH}"`.nothrow().quiet()

  // Remove port forwarding rules
  await removePortForwarding()
}

export function getLocalUrls(config: ProxyConfig = {}): Record<string, string> {
  const domain = config.domain || DOMAIN
  const services = { ...SERVICES, ...config.services }
  const proxyPort = config.port || 80

  const urls: Record<string, string> = {}
  for (const service of Object.keys(services)) {
    urls[service] = formatUrl(service, domain, proxyPort)
  }
  return urls
}
